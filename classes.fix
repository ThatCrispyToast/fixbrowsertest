/*
 * FixScript Classes v0.8 - https://www.fixscript.org/
 * Copyright (c) 2019-2024 Martin Dvorak <jezek2@advel.cz>
 *
 * This software is provided 'as-is', without any express or implied warranty.
 * In no event will the authors be held liable for any damages arising from
 * the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose, 
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

/*
The processing is as lightweight as possible to make it reasonably fast for
the interpreter. It uses these main techniques to achieve that:

- uses macros instead of function calls for token parsing to minimize overhead
- copies the tokens at bulk (in a deferred manner), individual token insertion
  is done only where necessary
- the parsing of expressions is converted to a loop instead of using traditional
  multiple nested functions to handle the operator priorities
- the expressions are parsed in descending order of the priorities and only
  when the priority is increased it will do a recursion
- the readibility is improved by using macros to organize the code
- the irony is that the actual processing of macros for this file takes way more
  time (unless preprocessed) than processing lot of classes, hopefully I will
  improve the code to not use macros and/or make them (much) faster to apply
*/

use "macros";

/*
TODO:
- add support for enums
*/

const {
	@TOK_IDENT,
	@TOK_FUNC_REF,
	@TOK_NUMBER,
	@TOK_HEX_NUMBER,
	@TOK_FLOAT_NUMBER,
	@TOK_CHAR,
	@TOK_STRING,
	@TOK_UNKNOWN,

	@KW_DO,
	@KW_IF,
	@KW_FOR,
	@KW_USE,
	@KW_VAR,
	@KW_CASE,
	@KW_ELSE,
	@KW_BREAK,
	@KW_CONST,
	@KW_WHILE,
	@KW_IMPORT,
	@KW_RETURN,
	@KW_SWITCH,
	@KW_DEFAULT,
	@KW_CONTINUE,
	@KW_FUNCTION
};

const {
	@TOK_type,
	@TOK_off,
	@TOK_len,
	@TOK_line,
	@TOK_SIZE
};

const {
	TYPE_DYNAMIC,
	TYPE_VOID,
	TYPE_INTEGER,
	TYPE_FLOAT,
	TYPE_BOOLEAN,
	TYPE_STRING,
	@TYPE_KEY,
	@TYPE_VALUE
};

const {
	EXT_TYPE_CLASS,
	EXT_TYPE_ARRAY,
	EXT_TYPE_HASH,
	EXT_TYPE_STRUCT,
	EXT_TYPE_STRUCT_ARRAY,
	EXT_TYPE_MULTIPLE
};

const {
	@CLASS_ext_type,
	@CLASS_name,
	@CLASS_compat_name,
	@CLASS_method_prefix,
	@CLASS_private,
	@CLASS_parent,
	@CLASS_fields,
	@CLASS_functions,
	@CLASS_virtual,
	@CLASS_supers,
	@CLASS_operators,
	@CLASS_generate_to_string,
	@CLASS_SIZE
};

const {
	@ARRAY_ext_type,
	@ARRAY_base_type,
	@ARRAY_SIZE
};

const {
	@HASH_ext_type,
	@HASH_base_type,
	@HASH_index_type,
	@HASH_SIZE
};

const {
	@FIELD_name,
	@FIELD_compat_name,
	@FIELD_private,
	@FIELD_type,
	@FIELD_SIZE
};

const {
	@FUNC_name,
	@FUNC_alt_name,
	@FUNC_flags,
	@FUNC_params,
	@FUNC_return_type,
	@FUNC_SIZE
};

const {
	@EXTENFUNC_kind = FUNC_SIZE,
	@EXTENFUNC_SIZE
};

const {
	@LOCAL_name,
	@LOCAL_private,
	@LOCAL_type,
	@LOCAL_SIZE
};

const {
	@FUNC_FLAG_PRIVATE     = 0x01,
	@FUNC_FLAG_STATIC      = 0x02,
	@FUNC_FLAG_VIRTUAL     = 0x04,
	@FUNC_FLAG_OVERRIDE    = 0x08,
	@FUNC_FLAG_ABSTRACT    = 0x10,
	@FUNC_FLAG_CONSTRUCTOR = 0x20,
	@FUNC_FLAG_OPERATOR    = 0x40,
	@FUNC_FLAG_EXTENSION   = 0x80
};

const {
	@GEN_result_tokens,
	@GEN_last_result_pos,
	@GEN_func_tokens,
	@GEN_last_func_pos,
	@GEN_func_offsets_replacements,
	@GEN_const_tokens,
	@GEN_first_const,
	@GEN_src,
	@GEN_vars,
	@GEN_var_stack,
	@GEN_ret_type,
	@GEN_cur_func,
	@GEN_consts,
	@GEN_cur_class,
	@GEN_parse_classes,
	@GEN_parse_funcs,
	@GEN_fname,
	@GEN_imported_scripts,
	@GEN_imported_locals,
	@GEN_imported_classes,
	@GEN_imported_functions,
	@GEN_imported_static_functions,
	@GEN_imported_instance_functions,
	@GEN_imported_operators,
	@GEN_classes,
	@GEN_functions,
	@GEN_static_functions,
	@GEN_instance_functions,
	@GEN_locals,
	@GEN_custom_ctx,
	@GEN_import_aliases,
	@GEN_uses_float_shorthands,
	@GEN_hash_entry_value_type,
	@GEN_fixide_cursor,
	@GEN_SIZE
};

const {
	@PRIO_LOGICAL_AND        = 0x11,
	@PRIO_LOGICAL_OR         = 0x12,
	@PRIO_COMPARISON_LT      = 0x21,
	@PRIO_COMPARISON_GT      = 0x22,
	@PRIO_COMPARISON_LE      = 0x23,
	@PRIO_COMPARISON_GE      = 0x24,
	@PRIO_EQUALITY_EQ_VALUE  = 0x25,
	@PRIO_EQUALITY_NE_VALUE  = 0x26,
	@PRIO_EQUALITY_EQ_REF    = 0x27,
	@PRIO_EQUALITY_NE_REF    = 0x28,
	@PRIO_BITWISE_AND        = 0x31,
	@PRIO_BITWISE_OR         = 0x32,
	@PRIO_BITWISE_XOR        = 0x33,
	@PRIO_BITWISE_SHL        = 0x34,
	@PRIO_BITWISE_SHR        = 0x35,
	@PRIO_BITWISE_USHR       = 0x36,
	@PRIO_ADDITIVE_ADD       = 0x41,
	@PRIO_ADDITIVE_SUB       = 0x42,
	@PRIO_MULTIPLICATIVE_MUL = 0x51,
	@PRIO_MULTIPLICATIVE_DIV = 0x52,
	@PRIO_MULTIPLICATIVE_REM = 0x53,
	@PRIO_PRIMARY            = 0x60
};

const {
	@PRIO_SPECIAL_COMPARE    = 0x70,
	@PRIO_SPECIAL_ADD_INPLACE,
	@PRIO_SPECIAL_SUB_INPLACE,
	@PRIO_SPECIAL_MUL_INPLACE,
	@PRIO_SPECIAL_DIV_INPLACE,
	@PRIO_SPECIAL_REM_INPLACE,
	@PRIO_SPECIAL_AND_INPLACE,
	@PRIO_SPECIAL_OR_INPLACE,
	@PRIO_SPECIAL_XOR_INPLACE,
	@PRIO_SPECIAL_SHL_INPLACE,
	@PRIO_SPECIAL_SHR_INPLACE,
	@PRIO_SPECIAL_USHR_INPLACE
};

const {
	@ET_HASH,
	@ET_STRING,
	@ET_FLOAT,
	@ET_BLOCK
};

const {
	@BT_NORMAL,
	@BT_SINGLE,
	@BT_EXPR
};

const {
	@FO_ADD_SUB,
	@FO_MUL_DIV
};

const {
	@CTX_function_calls,
	@CTX_function_calls_any,
	@CTX_postprocess,
	@CTX_gen,
	@CTX_required_checked,
	@CTX_required_origin,
	@CTX_append_tokens,
	@CTX_SIZE
};

const {
	@FUNC_CALL_get_types_func,
	@FUNC_CALL_adjust_call_func,
	@FUNC_CALL_data,
	@FUNC_CALL_SIZE
};

const {
	@IMPORT_ALIAS_consts,
	@IMPORT_ALIAS_locals,
	@IMPORT_ALIAS_funcs,
	@IMPORT_ALIAS_SIZE
};

const {
	@OPERATOR_prio,
	@OPERATOR_type1,
	@OPERATOR_type2,
	@OPERATOR_ret_type,
	@OPERATOR_func_name,
	@OPERATOR_compare,
	@OPERATOR_SIZE
};

const @class_ClassContext = "";
const @class_ClassType = "";
const @static_ClassContext_get_1 = "(String): ClassContext";
const @static_ClassContext_get_2 = "(String, Boolean): ClassContext";
const @method_ClassContext_register_function_call_5 = "(String, Dynamic, Dynamic, Dynamic): Void";
const @method_ClassContext_register_postprocess_3 = "(Dynamic, Dynamic): Void";
const @method_ClassContext_get_class_2 = "(String): ClassType";
const @method_ClassContext_get_const_type_2 = "(String): ClassType";
const @method_ClassContext_get_local_type_2 = "(String): ClassType";
const @method_ClassContext_get_variable_type_2 = "(String): ClassType";
const @method_ClassContext_get_source_1 = "(): String";
const @method_ClassContext_append_tokens_2 = "(Dynamic): Void";
const @static_ClassType_create_array_1 = "(ClassType): ClassType";
const @static_ClassType_create_hash_2 = "(ClassType, ClassType): ClassType";
const @method_ClassType_is_class_1 = "(): Boolean";
const @method_ClassType_is_array_1 = "(): Boolean";
const @method_ClassType_is_hash_1 = "(): Boolean";
const @method_ClassType_is_struct_1 = "(): Boolean";
const @method_ClassType_is_struct_array_1 = "(): Boolean";
const @method_ClassType_is_multiple_1 = "(): Boolean";
const @method_ClassType_is_assignable_from_2 = "(ClassType): Boolean";
const @method_ClassType_get_class_name_1 = "(): String";
const @method_ClassType_get_parent_class_1 = "(): ClassType";
const @method_ClassType_get_method_real_name_4 = "(String, ClassType[], Boolean): String";
const @method_ClassType_get_base_1 = "(): ClassType";
const @method_ClassType_get_index_1 = "(): ClassType";
const @method_ClassType_get_multiple_count_1 = "(): Integer";
const @method_ClassType_get_multiple_type_2 = "(Integer): ClassType";
const @method_ClassType_to_string_1 = "(): String";
const @static_ClassType_dump_list_1 = "(ClassType[]): Void";

var @classes, @functions, @locals;
var @static_functions, @instance_functions;
var @builtin_functions;
var @builtin_static_functions;
var @builtin_instance_functions;
var @tmp_cnt;
var @contexts;
var @parse_type_allow_generics;

var @initialized;
var @has_object_script;
var @fixide;

// >>> API ---------------------------------------------------------------------

function class_context_get(fname)
{
	return class_context_get(fname, true);
}

function class_context_get(fname, required)
{
	if (!contexts) {
		contexts = {};
	}
	var ctx = hash_get(contexts, fname, null);
	if (!ctx) {
		ctx = object_create(CTX_SIZE);
		ctx->CTX_function_calls = {};
		ctx->CTX_postprocess = [];
		contexts{fname} = ctx;
	}
	if (required && !ctx->CTX_required_checked) {
		var stack = error(null)[1];
		var idx = 1, s = stack[0];
		for (var i=length(s)-1; i>=0; i--) {
			if (s[i] == ':') {
				array_set_length(s, i+1);
				continue;
			}
			if (s[i] == '(') {
				array_remove(s, 0, i);
				break;
			}
		}
		var match = {"class_context_get#1 ", s};
		if (length(stack[idx]) >= length(match) && array_extract(stack[idx], 0, length(match)) == match) {
			idx++;
		}
		ctx->CTX_required_checked = true;
		ctx->CTX_required_origin = stack[idx];
		script_postprocess(check_required#4, ctx);
	}
	return ctx;
}

function @check_required(ctx, fname, tokens, src)
{
	if (contexts && hash_contains(contexts, fname)) {
		hash_remove(contexts, fname);
		if (length(contexts) == 0) {
			contexts = null;
		}
		return 0, error({fname, "(0): script must use classes, requested in: ", ctx->CTX_required_origin});
	}
}

// get_types(data, name, num_params, line)
// adjust_call(data, name, types, tokens, src, start, end)
function class_context_register_function_call(ctx, name, get_types_func, adjust_call_func, data)
{
	var list, register_to_all = false;

	if (name) {
		list = hash_get(ctx->CTX_function_calls, name, null);
		if (!list) {
			var function_calls_any = ctx->CTX_function_calls_any;
			list = function_calls_any? clone(function_calls_any) : [];
			ctx->CTX_function_calls{name} = list;
		}
	}
	else {
		list = ctx->CTX_function_calls_any;
		if (!list) {
			list = [];
			ctx->CTX_function_calls_any = list;
		}
		register_to_all = true;
	}

	list[] = get_types_func;
	list[] = adjust_call_func;
	list[] = data;
	
	if (register_to_all) {
		var function_calls = ctx->CTX_function_calls;
		for (var i=0; i<length(function_calls); i++) {
			var (k, v) = hash_entry(function_calls, i);
			v[] = get_types_func;
			v[] = adjust_call_func;
			v[] = data;
		}
	}
}

// postprocess(data, fname, tokens, src)
function class_context_register_postprocess(ctx, postprocess_func, data)
{
	ctx->CTX_postprocess[] = postprocess_func;
	ctx->CTX_postprocess[] = data;
}

function class_context_get_class(ctx, name)
{
	return find_class(ctx->CTX_gen, name);
}

function class_context_get_const_type(ctx, name)
{
	return hash_get(ctx->CTX_gen->GEN_consts, name, -1);
}

function class_context_get_local_type(ctx, name)
{
	var gen = ctx->CTX_gen;
	if (gen->GEN_locals) {
		var local = hash_get(gen->GEN_locals, name, null);
		if (local) {
			return local->LOCAL_type;
		}
	}
	if (gen->GEN_imported_locals) {
		var local = hash_get(gen->GEN_imported_locals, name, null);
		if (local) {
			return local->LOCAL_type;
		}
	}
	return -1;
}

function class_context_get_variable_type(ctx, name)
{
	return hash_get(ctx->CTX_gen->GEN_vars, name, -1);
}

function class_context_get_source(ctx)
{
	return ctx->CTX_gen->GEN_src;
}

function class_context_append_tokens(ctx, tokens)
{
	if (length(tokens) == 0) return;
	if (!ctx->CTX_append_tokens) {
		ctx->CTX_append_tokens = [];
	}
	ctx->CTX_append_tokens[] = tokens;
}

function class_type_create_array(base_type)
{
	return create_array_type(base_type);
}

function class_type_create_hash(base_type, index_type)
{
	return create_hash_type(base_type, index_type);
}

function class_type_is_class(type)
{
	return is_array(type) && type[0] == EXT_TYPE_CLASS;
}

function class_type_is_array(type)
{
	return is_array(type) && type[0] == EXT_TYPE_ARRAY;
}

function class_type_is_hash(type)
{
	return is_array(type) && type[0] == EXT_TYPE_HASH;
}

function class_type_is_struct(type)
{
	return is_array(type) && type[0] == EXT_TYPE_STRUCT;
}

function class_type_is_struct_array(type)
{
	return is_array(type) && type[0] == EXT_TYPE_STRUCT_ARRAY;
}

function class_type_is_multiple(type)
{
	return is_array(type) && type[0] == EXT_TYPE_MULTIPLE;
}

function class_type_is_assignable_from(type, other)
{
	return is_compatible_type(type, other);
}

function class_type_get_class_name(type)
{
	return type->CLASS_name;
}

function class_type_get_parent_class(type)
{
	return type->CLASS_parent;
}

function class_type_get_method_real_name(type, name, types, is_static)
{
	var func_name = {name, "#", length(types)-1};
	var func = null;
	var cls = type;
	while (cls) {
		func = hash_get(cls->CLASS_functions, func_name, null);
		if (func && (func->FUNC_flags & FUNC_FLAG_OVERRIDE) == 0) break;
		cls = cls->CLASS_parent;
	}
	if (!func) return null;

	if (is_static) {
		if (!(func->FUNC_flags & FUNC_FLAG_STATIC)) {
			return null;
		}
	}
	else {
		if (func->FUNC_flags & FUNC_FLAG_STATIC) {
			return null;
		}
	}

	if (!is_compatible_type(types[0], func->FUNC_return_type)) {
		return null;
	}

	for (var i=1; i<length(types); i++) {
		var (k, v) = hash_entry(func->FUNC_params, i-1);
		if (!is_compatible_type(v, types[i])) {
			return null;
		}
	}

	return {cls->CLASS_method_prefix, func->FUNC_name};
}

function class_type_get_base(type)
{
	switch (type[0]) {
		case EXT_TYPE_ARRAY: return type->ARRAY_base_type;
		case EXT_TYPE_HASH: return type->HASH_base_type;
		case EXT_TYPE_STRUCT_ARRAY: return type->ARRAY_base_type;
	}
	return 0, error("bad type");
}

function class_type_get_index(type)
{
	switch (type[0]) {
		case EXT_TYPE_HASH: return type->HASH_index_type;
	}
	return 0, error("bad type");
}

function class_type_get_multiple_count(type)
{
	switch (type[0]) {
		case EXT_TYPE_MULTIPLE: return length(type)-1;
	}
	return 0, error("bad type");
}

function class_type_get_multiple_type(type, idx)
{
	switch (type[0]) {
		case EXT_TYPE_MULTIPLE: return type[idx+1];
	}
	return 0, error("bad type");
}

function class_type_to_string(type)
{
	return get_type_name(type);
}

function class_type_dump_list(list)
{
	var s = {"[\n"};
	for (var i=0; i<length(list); i++) {
		array_append(s, "  \"");
		array_append(s, get_type_name(list[i]));
		s[] = '"';
		if (i < length(list)-1) {
			s[] = ',';
		}
		s[] = '\n';
	}
	s[] = ']';
	log(s);
}

// <<< API ---------------------------------------------------------------------

macro @token_list(list) { list#_tokens, list#_src, list#_off }

macro @token_list_declare(&list, tokens, src) { var list#_tokens = tokens, list#_src = src, list#_off = -4; }
macro @token_list_reset(list) { list#_off = -4; }
macro @token_next(list) { ((list#_off += TOK_SIZE) < length(list#_tokens)) }
macro @token_next_nocheck(list) { list#_off += TOK_SIZE; }
macro @token_back(list) { list#_off -= TOK_SIZE; }

macro @token_get_pos(list) { (list#_off) }
macro @token_set_pos(list, off) { list#_off = off; }

macro @token_get_type(list) { (list#_tokens[list#_off]) }
macro @token_set_type(list, type) { list#_tokens[list#_off] = type; }
macro @token_get_offset(list) { (list#_tokens[list#_off+TOK_off]) }
macro @token_set_offset(list, off) { list#_tokens[list#_off+TOK_off] = off; }
macro @token_get_length(list) { (list#_tokens[list#_off+TOK_len]) }
macro @token_set_length(list, len) { list#_tokens[list#_off+TOK_len] = len; }
macro @token_get_line(list) { (list#_tokens[list#_off+TOK_line]) }
macro @token_set_line(list, line) { list#_tokens[list#_off+TOK_line] = line; }
macro @token_get_symbol1(list) { (list#_src[list#_tokens[list#_off+TOK_off]]) }
macro @token_get_value(list) { array_extract(list#_src, list#_tokens[list#_off+TOK_off], list#_tokens[list#_off+TOK_len]) }
macro @token_get_const_value(list) { string_const(list#_src, list#_tokens[list#_off+TOK_off], list#_tokens[list#_off+TOK_len]) }
macro @token_has_value(list, value) { (list#_tokens[list#_off+TOK_len] === length(value) && token_get_value(list) == (value)) }
macro @token_is_ident(list, value) { (list#_tokens[list#_off] === TOK_IDENT && token_has_value(list, value)) }
macro @token_is_symbol(list, c1) { (list#_tokens[list#_off] === (c1)) }
macro @token_get_string_literal(list) { token_parse_string(list#_src, list#_tokens[list#_off+TOK_off], list#_tokens[list#_off+TOK_len]) }
macro @token_get_number_literal(list) { string_parse_int(token_get_value(list)) }

macro @token_set_do(list, line) { token_set(list, KW_DO, "do", line); }
macro @token_set_for(list, line) { token_set(list, KW_FOR, "for", line); }
macro @token_set_var(list, line) { token_set(list, KW_VAR, "var", line); }
macro @token_set_use(list, line) { token_set(list, KW_USE, "use", line); }
macro @token_set_else(list, line) { token_set(list, KW_ELSE, "else", line); }
macro @token_set_case(list, line) { token_set(list, KW_CASE, "case", line); }
macro @token_set_while(list, line) { token_set(list, KW_WHILE, "while", line); }
macro @token_set_break(list, line) { token_set(list, KW_BREAK, "break", line); }
macro @token_set_const(list, line) { token_set(list, KW_CONST, "const", line); }
macro @token_set_return(list, line) { token_set(list, KW_RETURN, "return", line); }
macro @token_set_import(list, line) { token_set(list, KW_IMPORT, "import", line); }
macro @token_set_switch(list, line) { token_set(list, KW_SWITCH, "switch", line); }
macro @token_set_default(list, line) { token_set(list, KW_DEFAULT, "default", line); }
macro @token_set_function(list, line) { token_set(list, KW_FUNCTION, "function", line); }
macro @token_set_continue(list, line) { token_set(list, KW_CONTINUE, "continue", line); }

macro @token_set(list, type, value, line)
{
	list#_tokens[list#_off] = type;
	list#_tokens[list#_off+TOK_off] = length(list#_src);
	list#_tokens[list#_off+TOK_len] = length(value);
	list#_tokens[list#_off+TOK_line] = line;
	_tokens_array_append(list#_src, value);
}

macro @token_add_do(list, line) { token_add(list, KW_DO, "do", line); }
macro @token_add_for(list, line) { token_add(list, KW_FOR, "for", line); }
macro @token_add_var(list, line) { token_add(list, KW_VAR, "var", line); }
macro @token_add_use(list, line) { token_add(list, KW_USE, "use", line); }
macro @token_add_else(list, line) { token_add(list, KW_ELSE, "else", line); }
macro @token_add_case(list, line) { token_add(list, KW_CASE, "case", line); }
macro @token_add_while(list, line) { token_add(list, KW_WHILE, "while", line); }
macro @token_add_break(list, line) { token_add(list, KW_BREAK, "break", line); }
macro @token_add_const(list, line) { token_add(list, KW_CONST, "const", line); }
macro @token_add_return(list, line) { token_add(list, KW_RETURN, "return", line); }
macro @token_add_import(list, line) { token_add(list, KW_IMPORT, "import", line); }
macro @token_add_switch(list, line) { token_add(list, KW_SWITCH, "switch", line); }
macro @token_add_default(list, line) { token_add(list, KW_DEFAULT, "default", line); }
macro @token_add_function(list, line) { token_add(list, KW_FUNCTION, "function", line); }
macro @token_add_continue(list, line) { token_add(list, KW_CONTINUE, "continue", line); }

macro @token_add(list, type, value, line)
{
	list#_tokens[] = type;
	list#_tokens[] = length(list#_src);
	list#_tokens[] = length(value);
	list#_tokens[] = line;
	_tokens_array_append(list#_src, value);
}

macro @token_add_complex(list, type, value, line)
{
	var $value = value;
	list#_tokens[] = type;
	list#_tokens[] = length(list#_src);
	list#_tokens[] = length($value);
	list#_tokens[] = line;
	_tokens_array_append(list#_src, $value);
}

macro @token_add_copy(list, src_list)
{
	var $off = src_list#_off;
	list#_tokens[] = src_list#_tokens[$off++];
	list#_tokens[] = src_list#_tokens[$off++];
	list#_tokens[] = src_list#_tokens[$off++];
	list#_tokens[] = src_list#_tokens[$off];
}

macro @token_add_copy_and_advance(list, src_list)
{
	list#_tokens[] = src_list#_tokens[src_list#_off++];
	list#_tokens[] = src_list#_tokens[src_list#_off++];
	list#_tokens[] = src_list#_tokens[src_list#_off++];
	list#_tokens[] = src_list#_tokens[src_list#_off++];
}

macro @token_add_copy_full(list, src_list)
{
	token_add_copy(list, src_list);
	var $off = length(list#_tokens) - TOK_SIZE;
	tokens[$off+TOK_off] = length(list#_src);
	_tokens_array_append(list#_src, src_list#_src, src_list#_tokens[src_list#_off+TOK_off], src_list#_tokens[src_list#_off+TOK_len]);
}

macro @_tokens_array_append(arr, other)
{
	var $off = length(arr);
	array_set_length(arr, $off + length(other));
	array_copy(arr, $off, other, 0, length(other));
}

macro @_tokens_array_insert_range(arr, idx, cnt)
{
	array_set_length(arr, length(arr) + cnt);
	array_copy(arr, idx+cnt, arr, idx, length(arr) - idx);
}

function @token_type_to_string(type)
{
	switch (type) {
		case TOK_IDENT:        return "TOK_IDENT";
		case TOK_FUNC_REF:     return "TOK_FUNC_REF";
		case TOK_NUMBER:       return "TOK_NUMBER";
		case TOK_HEX_NUMBER:   return "TOK_HEX_NUMBER";
		case TOK_FLOAT_NUMBER: return "TOK_FLOAT_NUMBER";
		case TOK_CHAR:         return "TOK_CHAR";
		case TOK_STRING:       return "TOK_STRING";
		case TOK_UNKNOWN:      return "TOK_UNKNOWN";

		case KW_DO:       return "KW_DO";
		case KW_IF:       return "KW_IF";
		case KW_FOR:      return "KW_FOR";
		case KW_VAR:      return "KW_VAR";
		case KW_USE:      return "KW_USE";
		case KW_ELSE:     return "KW_ELSE";
		case KW_CASE:     return "KW_CASE";
		case KW_WHILE:    return "KW_WHILE";
		case KW_BREAK:    return "KW_BREAK";
		case KW_CONST:    return "KW_CONST";
		case KW_RETURN:   return "KW_RETURN";
		case KW_IMPORT:   return "KW_IMPORT";
		case KW_SWITCH:   return "KW_SWITCH";
		case KW_DEFAULT:  return "KW_DEFAULT";
		case KW_FUNCTION: return "KW_FUNCTION";
		case KW_CONTINUE: return "KW_CONTINUE";
	}

	var c0 = type & 0xFF;
	var c1 = (type >>> 8) & 0xFF;
	var c2 = (type >>> 16) & 0xFF;
	var c3 = (type >>> 24) & 0xFF;
	var s = {""};
	s[] = c0;
	if (c1) {
		s[] = c1;
		if (c2) {
			s[] = c2;
			if (c3) {
				s[] = c3;
			}
		}
	}
	return s;
}

function @_tokens_get_desc(type)
{
	switch (type) {
		case TOK_IDENT:        return "identifier";
		case TOK_FUNC_REF:     return "function reference";
		case TOK_NUMBER:       return "number literal";
		case TOK_HEX_NUMBER:   return "hex number literal";
		case TOK_FLOAT_NUMBER: return "float number literal";
		case TOK_CHAR:         return "character literal";
		case TOK_STRING:       return "string literal";
		case TOK_UNKNOWN:      return "unknown";

		case KW_DO:       return "keyword 'do'";
		case KW_IF:       return "keyword 'if'";
		case KW_FOR:      return "keyword 'for'";
		case KW_VAR:      return "keyword 'var'";
		case KW_USE:      return "keyword 'use'";
		case KW_ELSE:     return "keyword 'else'";
		case KW_CASE:     return "keyword 'case'";
		case KW_WHILE:    return "keyword 'while'";
		case KW_BREAK:    return "keyword 'break'";
		case KW_CONST:    return "keyword 'const'";
		case KW_RETURN:   return "keyword 'return'";
		case KW_IMPORT:   return "keyword 'import'";
		case KW_SWITCH:   return "keyword 'switch'";
		case KW_DEFAULT:  return "keyword 'default'";
		case KW_FUNCTION: return "keyword 'function'";
		case KW_CONTINUE: return "keyword 'continue'";
	}
	return {"symbol '", token_type_to_string(type), "'"};
}

function @_tokens_char(c)
{
	var s = {" "};
	s[0] = c;
	return s;
}

macro @token_expect_next(list)
{
	if (!token_next(list)) {
		return 0, error("unexpected end of file");
	}
}

macro @token_expect_type(list, type)
{
	if (!token_next(list)) {
		return 0, error("unexpected end of file");
	}
	if (list#_tokens[list#_off] !== type) {
		return 0, error({script_line(list#_tokens[list#_off+TOK_line]), ": expected ", _tokens_get_desc(type)});
	}
}

macro @token_expect_symbol(list, c1)
{
	if (!token_next(list)) {
		return 0, error("unexpected end of file");
	}
	if (list#_tokens[list#_off] !== c1) {
		return 0, error({script_line(list#_tokens[list#_off+TOK_line]), ": expected symbol '", _tokens_char(c1), "'"});
	}
}

macro @token_expect_expression(list)
{
	var $level = 0;
	list#_off += TOK_SIZE;
	for (; list#_off < length(list#_tokens); list#_off += TOK_SIZE) {
		switch (list#_tokens[list#_off]) {
			case '(', '{', '[':
				$level++;
				continue;
			case ')', '}', ']':
				if (!$level) break;
				$level--;
				continue;
			case ',', ';':
				if (!$level) break;
				continue;
			default:
				continue;
		}
		break;
	}
	list#_off -= TOK_SIZE;
}

macro @token_expect_statement(list)
{
	token_expect_next(list);
	if (token_get_type(list) === '{') {
		for (;;) {
			token_expect_expression(list);
			token_expect_next(list);
			if (token_is_symbol(list, '}')) break;
			token_back(list);
		}
		token_expect_symbol(list, '}');
	}
	else {
		token_expect_expression(list);
		token_expect_symbol(list, ';');
	}
}

macro @token_dump(list)
{
	log({"type=", token_type_to_string(token_get_type(list)), " value='", token_get_value(list), "' line=", token_get_line(list)});
}

macro @token_list_dump(list) { _token_list_dump(list#_tokens, list#_src); }

function @_token_list_dump(tokens, src)
{
	var s = {""};
	var last_line = 1, last_type = -1;
	
	for (var i=0; i<length(tokens); i+=TOK_SIZE) {
		if (last_line != tokens[i+TOK_line]) {
			s[] = '\n';
			last_line = tokens[i+TOK_line];
		}
		else {
			if (last_type < ' ' && tokens[i+TOK_type] < ' ') {
				s[] = ' ';
			}
		}
		var len = length(s);
		array_set_length(s, len + tokens[i+TOK_len]);
		array_copy(s, len, src, tokens[i+TOK_off], tokens[i+TOK_len]);
		last_type = tokens[i+TOK_type];
	}
	log(s);
}

macro @_copy_tokens(name, gen, list)
{
	var $tokens = gen->GEN_#name#_tokens;
	var $off = length($tokens);
	var $cnt = list#_off - gen->GEN_last_#name#_pos;
	array_set_length($tokens, $off + $cnt);
	array_copy($tokens, $off, list#_tokens, gen->GEN_last_#name#_pos, $cnt);
	gen->GEN_last_#name#_pos = list#_off;
}

macro @_insert_tokens(name, gen, list, off, adj, cnt, &tokens, &pos)
{
	var tokens = gen->GEN_#name#_tokens;
	var pos = length(tokens) - TOK_SIZE;
	var $cmp_off = off >= 0? list#_tokens[off+TOK_off] : tokens[-off+TOK_off];
	while (tokens[pos+TOK_off] !== $cmp_off) {
		pos -= TOK_SIZE;
	}
	pos += TOK_SIZE + (adj);
	var $off = length(tokens);
	var $cnt = (cnt) * TOK_SIZE;
	array_set_length(tokens, $off+$cnt);
	array_copy(tokens, pos+$cnt, tokens, pos, $off-pos);
}

macro @insert_token(tokens, pos, type, off, len, line)
{
	tokens[pos++] = type;
	tokens[pos++] = off;
	tokens[pos++] = len;
	tokens[pos++] = line;
}

macro @append_token(tokens, type, off, len, line)
{
	tokens[] = type;
	tokens[] = off;
	tokens[] = len;
	tokens[] = line;
}

macro @append_source(src, content, &off)
{
	var off = length(src);
	array_set_length(src, off + length(content));
	array_copy(src, off, content, 0, length(content));
}

macro @_set_copy_start(name, gen, list)
{
	gen->GEN_last_#name#_pos = list#_off;
}

macro @copy_result_tokens(gen, list) { _copy_tokens(result, gen, list); }
macro @set_result_copy_start(gen, list) { _set_copy_start(result, gen, list); }

macro @copy_func_tokens(gen, list) { _copy_tokens(func, gen, list); }
macro @insert_func_tokens(gen, list, off, cnt, &tokens, &pos) { _insert_tokens(func, gen, list, off, 0, cnt, &tokens, &pos); }
macro @insert_func_tokens_adj(gen, list, off, adj, cnt, &tokens, &pos) { _insert_tokens(func, gen, list, off, adj, cnt, &tokens, &pos); }
macro @set_func_copy_start(gen, list) { _set_copy_start(func, gen, list); }

function @replace_array(dest, src)
{
	array_set_length(dest, length(src));
	array_copy(dest, 0, src, 0, length(src));
}

function @string_starts_with(s, match)
{
	var len = length(match);
	if (length(s) < len) return false;
	return array_extract(s, 0, len) == match;
}

function @merge_hash(dest, src)
{
	for (var i=0; i<length(src); i++) {
		var (k, v) = hash_entry(src, i);
		dest{k} = v;
	}
}

function process_tokens(fname, tokens, src)
{
	if (!initialized) {
		initialized = true;
		classes = {};
		functions = {};
		static_functions = {};
		instance_functions = {};
		locals = {};
		init_builtin_functions();
		var (r1, e1) = script_query("object", null, null, null, null);
		var (r2, e2) = @fixide_is_present();
		has_object_script = !e1;
		fixide = r2;
	}

	token_list_declare(&list, tokens, src);
	if (has_object_script && fname != "object.fix") {
		token_expect_expression(list);
		token_expect_symbol(list, ';');

		while (token_next(list)) {
			if (token_get_type(list) == KW_USE) {
				token_expect_type(list, TOK_STRING);
				for (;;) {
					token_expect_expression(list);
					if (!token_next(list)) break;
					if (token_is_symbol(list, ';')) {
						token_back(list);
						break;
					}
				}
				token_expect_symbol(list, ';');
				continue;
			}
			break;
		}
		if (has_object_script) {
			array_insert_array(tokens, token_get_pos(list), tokens_parse([], src, "import \"object\";", token_get_line(list)));
			token_back(list);
		}
	}

	var gen = object_create(GEN_SIZE);
	gen->GEN_result_tokens = [];
	gen->GEN_func_tokens = [];
	gen->GEN_func_offsets_replacements = {};
	gen->GEN_const_tokens = [];
	gen->GEN_src = src;
	gen->GEN_vars = {};
	gen->GEN_var_stack = [];
	gen->GEN_consts = {};
	gen->GEN_parse_classes = [];
	gen->GEN_parse_funcs = [];
	gen->GEN_fname = fname;
	gen->GEN_imported_scripts = {};
	gen->GEN_imported_classes = {};
	gen->GEN_imported_functions = {};
	gen->GEN_imported_operators = {};
	gen->GEN_classes = {};
	gen->GEN_functions = {};
	if (contexts) {
		var ctx = hash_get(contexts, fname, null);
		if (ctx) {
			hash_remove(contexts, fname);
			if (length(contexts) == 0) {
				contexts = null;
			}
			ctx->CTX_gen = gen;
			gen->GEN_custom_ctx = ctx;
		}
	}
	if (fixide) {
		gen->GEN_fixide_cursor = @fixide_get_cursor(fname);
	}
	classes{fname} = gen->GEN_classes;
	functions{fname} = gen->GEN_functions;

	process_tokens_inner(gen, token_list(list));

	if (gen->GEN_custom_ctx) {
		for (;;) {
			var append_tokens = gen->GEN_custom_ctx->CTX_append_tokens;
			if (append_tokens && length(append_tokens) > 0) {
				var new_tokens = append_tokens[0];
				array_remove(append_tokens, 0);
				token_list_declare(&new_list, new_tokens, src);
				token_next_nocheck(new_list);
				set_result_copy_start(gen, new_list);
				token_back(new_list);
				hash_clear(gen->GEN_func_offsets_replacements);
				process_tokens_inner(gen, token_list(new_list));
				continue;
			}
			break;
		}
	}

	replace_array(tokens, gen->GEN_result_tokens);
	token_list_reset(list);
	var inserted = false;
	while (token_next(list)) {
		switch (token_get_type(list)) {
			case KW_VAR, KW_FUNCTION:
				array_insert_array(tokens, token_get_pos(list), gen->GEN_const_tokens);
				inserted = true;
				break;
		}
		if (inserted) break;
	}
	if (!inserted) {
		array_append(tokens, gen->GEN_const_tokens);
	}

	array_append(tokens, gen->GEN_func_tokens);
	//perf_log("reparsing");

	if (gen->GEN_uses_float_shorthands) {
		process_float_shorthands(tokens, src);
	}

	for (var i=0; i<length(gen->GEN_classes); i++) {
		var (k, v) = hash_entry(gen->GEN_classes, i);
		if (v->CLASS_private) {
			hash_remove(gen->GEN_classes, k);
			i--;
			continue;
		}
		for (var j=0; j<length(v->CLASS_fields); j++) {
			var (k2, v2) = hash_entry(v->CLASS_fields, j);
			if (v2->FIELD_private) {
				hash_remove(v->CLASS_fields, k2);
				j--;
				continue;
			}
		}
		for (var j=0; j<length(v->CLASS_functions); j++) {
			var (k2, v2) = hash_entry(v->CLASS_functions, j);
			if (v2->FUNC_flags & FUNC_FLAG_PRIVATE) {
				hash_remove(v->CLASS_functions, k2);
				j--;
				continue;
			}
		}
	}

	for (var i=0; i<length(gen->GEN_functions); i++) {
		var (k, v) = hash_entry(gen->GEN_functions, i);
		if (v->FUNC_flags & (FUNC_FLAG_PRIVATE | FUNC_FLAG_EXTENSION)) {
			hash_remove(gen->GEN_functions, k);
			i--;
			continue;
		}
	}

	if (gen->GEN_locals) {
		for (var i=0; i<length(gen->GEN_locals); i++) {
			var (k, v) = hash_entry(gen->GEN_locals, i);
			if (v->LOCAL_private) {
				hash_remove(gen->GEN_locals, k);
				i--;
				continue;
			}
		}
		if (length(gen->GEN_locals) == 0) {
			hash_remove(locals, fname);
		}
	}

	if (gen->GEN_custom_ctx) {
		var postprocess = gen->GEN_custom_ctx->CTX_postprocess;
		for (var i=length(postprocess)-2; i>=0; i-=2) {
			postprocess[i+0](postprocess[i+1], fname, tokens, src);
		}
	}

	//if (gen->GEN_custom_ctx) {
	//token_list_dump(list);
	//dump(gen->GEN_consts);
	//return 0, 1;
	//}
}

function @process_tokens_inner(gen, token_list(list))
{
	var fname = gen->GEN_fname;
	var src = list_src;
	var parse_locals = null;

	//heap_collect();
	//perf_reset();
	while (token_next(list)) {
		switch (token_get_type(list)) {
			case KW_IMPORT: {
				var import_pos = token_get_pos(list);
				var import_line = token_get_line(list);
				token_expect_type(list, TOK_STRING);
				var script_name = token_parse_string(token_get_value(list));
				var script_alias = null;
				token_expect_next(list);
				if (token_is_symbol(list, ':')) {
					token_expect_type(list, TOK_IDENT);
					script_alias = token_get_value(list);
				}
				else {
					token_back(list);
				}
				token_expect_symbol(list, ';');
				var import_fname = {""};
				var consts = {};
				if (script_alias) {
					var locals = [];
					var funcs = [];
					script_query(script_name, import_fname, consts, locals, funcs);
					var consts_map = {};
					for (var i=0; i<length(consts); i++) {
						var (k, v) = hash_entry(consts, i);
						if (k[0] == '@') continue;
						if (is_array(v)) {
							v = v[0];
						}
						var type = TYPE_DYNAMIC;
						if (is_int(v)) {
							type = TYPE_INTEGER;
						}
						else if (is_float(v)) {
							type = TYPE_FLOAT;
						}
						else if (is_string(v)) {
							type = TYPE_STRING;
						}
						consts_map{k} = type;
					}
					var locals_set = {};
					for (var i=0; i<length(locals); i++) {
						locals_set{locals[i]} = true;
					}
					var funcs_set = {};
					for (var i=0; i<length(funcs); i++) {
						var name = funcs[i];
						funcs_set{name} = true;
						name = {name};
						for (var j=length(name)-1; j>=0; j--) {
							if (name[j] == '#') {
								array_set_length(name, j);
								break;
							}
						}
						funcs_set{name} = true;
					}
					var ia = object_create(IMPORT_ALIAS_SIZE);
					ia->IMPORT_ALIAS_consts = consts_map;
					ia->IMPORT_ALIAS_locals = locals_set;
					ia->IMPORT_ALIAS_funcs = funcs_set;
					if (!gen->GEN_import_aliases) {
						gen->GEN_import_aliases = {};
					}
					gen->GEN_import_aliases{script_alias} = ia;
				}
				else {
					var (r, e) = script_query(script_name, import_fname, consts, null, null);
					if (is_array(e) && length(e) >= 2 && is_string(e[0])) {
						// TODO: could this be done better?
						var s = e[0];
						var prefix = "script ";
						var suffix = " not found";
						if (length(s) >= length(prefix)+length(suffix) && array_extract(s, 0, length(prefix)) == prefix && array_extract(s, length(s)-length(suffix), length(suffix)) == suffix) {
							return 0, error({script_line(token_get_line(list)), ": ", s});
						}
						else {
							return 0, e;
						}
					}
					else if (e) {
						return 0, e;
					}
				}
				var import_state = hash_get(gen->GEN_imported_scripts, script_name, 0);
				if (import_state == 3) {
					gen->GEN_imported_scripts{script_name} = 2;
				}
				else if (import_state == 2) {
					gen->GEN_imported_scripts{script_name} = 1;
					array_remove(list_tokens, import_pos, token_get_pos(list) - import_pos + TOK_SIZE);
					token_set_pos(list, import_pos - TOK_SIZE);
					continue;
				}
				else {
					gen->GEN_imported_scripts{script_name} = 1;
				}
				var import_scripts = hash_get(consts, "@import_scripts", null);
				if (import_scripts) {
					var scripts = string_split(import_scripts, ',');
					var new_tokens = null;
					for (var i=0; i<length(scripts); i++) {
						var script = scripts[i];
						if (hash_contains(gen->GEN_imported_scripts, script)) continue;
						if (!new_tokens) {
							new_tokens = [];
						}
						tokens_parse(new_tokens, src, {"import ", token_escape_string(script), ";"}, import_line);
						gen->GEN_imported_scripts{script} = 3;
					}
					if (new_tokens) {
						array_insert_array(list_tokens, import_pos, new_tokens);
						token_set_pos(list, import_pos - TOK_SIZE);
						continue;
					}
				}
				var import_classes = hash_get(classes, import_fname, null);
				if (import_classes) {
					for (var i=0; i<length(import_classes); i++) {
						var (cls_name, v) = hash_entry(import_classes, i);
						if (!v->CLASS_private && !hash_contains(gen->GEN_imported_classes, cls_name)) {
							gen->GEN_imported_classes{cls_name} = v;
							var operators = v->CLASS_operators;
							if (operators) {
								merge_operators(gen->GEN_imported_operators, operators);
							}
						}
					}
					for (var i=0; i<length(consts); i++) {
						var (k, v) = hash_entry(consts, i);
						if (k[0] == '@') continue;
						if (!hash_contains(gen->GEN_consts, k)) {
							if (is_array(v)) {
								v = v[0];
							}
							gen->GEN_consts{k} = is_string(v)? TYPE_STRING : is_float(v)? TYPE_FLOAT : TYPE_INTEGER;
						}
					}
				}
				else {
					var class_attribs = null;
					var funcs = null;
					macro ensure_funcs() {
						if (!funcs) {
							var $list = [];
							script_query(script_name, null, null, null, $list);
							funcs = {};
							for (var $i=0; $i<length($list); $i++) {
								funcs{$list[$i]} = true;
							}
						}
					}
					for (var i=0; i<length(consts); i++) {
						var (k, v) = hash_entry(consts, i);
						var private = (k[0] == '@');
						if (private && length(k) > 5) {
							var short = k[1] | (k[2] << 8) | (k[3] << 16) | (k[4] << 24);
							switch (short) {
								case 'clas':
									if (length(k) > 7 && array_extract(k, 1, 6) == "class_") {
										var cls_name = string_const(k, 7, length(k)-7);
										class_attribs = parse_class_attrib(gen, import_fname, cls_name, v, class_attribs, token_get_line(list));
									}
									break;

								case 'glob':
									if (length(k) > 8 && array_extract(k, 1, 7) == "global_") {
										var func_name = array_extract(k, 8, length(k)-8);
										for (var j=length(func_name)-1; j>=0; j--) {
											if (func_name[j] == '_') {
												func_name[j] = '#';
												break;
											}
										}
										ensure_funcs();
										var (func, e) = parse_method_attrib(gen, null, func_name, v, null, true, false, funcs, token_get_line(list));
										if (e) {
											return 0, adjust_method_attrib_error(fname, token_get_line(list), e, null, func_name);
										}
										var map = hash_get(functions, import_fname, null);
										if (!map) {
											map = {};
											functions{import_fname} = map;
										}
										map{func_name} = func;
									}
									break;
							}
							continue;
						}
						if (!private && !hash_contains(gen->GEN_consts, k)) {
							if (is_array(v)) {
								v = v[0];
							}
							gen->GEN_consts{k} = is_string(v)? TYPE_STRING : is_float(v)? TYPE_FLOAT : TYPE_INTEGER;
						}
					}
					if (class_attribs) {
						ensure_funcs();
						class_attribs = finish_class_attribs(gen, class_attribs, consts, funcs);
						for (var i=0; i<length(consts); i++) {
							var (k, v) = hash_entry(consts, i);
							if (k[0] == '@' && length(k) > 5) {
								var short = k[1] | (k[2] << 8) | (k[3] << 16) | (k[4] << 24);
								switch (short) {
									case 'fiel':
										if (length(k) > 7 && array_extract(k, 1, 6) == "field_") {
											consts{k} = null;
											var cls_name = null;
											var field_name = array_extract(k, 7, length(k)-7);
											for (var j=0; j<length(class_attribs); j++) {
												var (name, map) = hash_entry(class_attribs, j);
												if (length(name)+1 < length(field_name)) {
													if (array_extract(field_name, 0, length(name)) == name && field_name[length(name)] == '_') {
														cls_name = name;
														array_remove(field_name, 0, length(name)+1);
														break;
													}
												}
											}
											if (cls_name) {
												var (r, e) = parse_field_attrib(gen, cls_name, field_name, v, class_attribs, token_get_line(list));
												if (e) {
													return 0, adjust_field_attrib_error(fname, token_get_line(list), e, cls_name, field_name);
												}
											}
										}
										break;

									case 'meth', 'stat':
										if (length(k) > 8 && ((short == 'meth' && array_extract(k, 1, 7) == "method_") || (short == 'stat' && array_extract(k, 1, 7) == "static_"))) {
											consts{k} = null;
											var is_static = (k[1] == 's');
											var cls_name = null;
											var method_name = array_extract(k, 8, length(k)-8);
											for (var j=0; j<length(class_attribs); j++) {
												var (name, map) = hash_entry(class_attribs, j);
												if (length(name)+1 < length(method_name)) {
													if (array_extract(method_name, 0, length(name)) == name && method_name[length(name)] == '_') {
														cls_name = name;
														array_remove(method_name, 0, length(name)+1);
														break;
													}
												}
											}
											if (cls_name) {
												for (var j=length(method_name)-1; j>=0; j--) {
													if (method_name[j] == '_') {
														method_name[j] = '#';
														break;
													}
												}
												var (r, e) = parse_method_attrib(gen, cls_name, method_name, v, class_attribs, is_static, false, null, token_get_line(list));
												if (e) {
													return 0, adjust_method_attrib_error(fname, token_get_line(list), e, cls_name, method_name);
												}
											}
										}
										break;

									case 'oper':
										if (length(k) > 10 && array_extract(k, 1, 9) == "operator_") {
											consts{k} = null;
											var cls_name = null;
											var op_name = array_extract(k, 10, length(k)-10);
											for (var j=length(op_name)-1; j>=0; j--) {
												if (op_name[j] == '_') {
													array_set_length(op_name, j);
													break;
												}
											}
											for (var j=length(op_name)-1; j>=0; j--) {
												if (op_name[j] == '_') {
													cls_name = array_extract(op_name, 0, j);
													array_remove(op_name, 0, j+1);
													break;
												}
											}
											if (cls_name) {
												if (op_name == "inplace") {
													for (var j=length(cls_name)-1; j>=0; j--) {
														if (cls_name[j] == '_') {
															array_insert(op_name, 0, '_');
															array_insert_array(op_name, 0, cls_name, j+1, length(cls_name)-j-1);
															array_set_length(cls_name, j);
															break;
														}
													}
												}
												ensure_funcs();
												var (r, e) = parse_operator_attrib(gen, cls_name, op_name, v, class_attribs, funcs, token_get_line(list));
												if (e) {
													return 0, adjust_operator_attrib_error(fname, token_get_line(list), e, cls_name, op_name);
												}
											}
										}
										break;
								}
							}
						}
					}
					for (var i=0; i<length(consts); i++) {
						var (k, v) = hash_entry(consts, i);
						if (k[0] == '@' && length(k) > 5 && v) {
							var short = k[1] | (k[2] << 8) | (k[3] << 16) | (k[4] << 24);
							var match = false;
							switch (short) {
								case 'fiel':
									if (length(k) > 7 && array_extract(k, 1, 6) == "field_") {
										match = true;
									}
									break;

								case 'meth':
									if (length(k) > 14 && array_extract(k, 1, 13) == "method_Array_") {
										ensure_funcs();
										parse_extension_method_attrib(gen, "array", k, v, false, 2, funcs, token_get_line(list));
										break;
									}
									if (length(k) > 15 && array_extract(k, 1, 14) == "method_String_") {
										ensure_funcs();
										parse_extension_method_attrib(gen, "string", k, v, false, 0, funcs, token_get_line(list));
										break;
									}
									if (length(k) > 13 && array_extract(k, 1, 12) == "method_Hash_") {
										ensure_funcs();
										parse_extension_method_attrib(gen, "hash", k, v, false, 1 | 2, funcs, token_get_line(list));
										break;
									}
									if (length(k) > 8 && array_extract(k, 1, 7) == "method_") {
										match = true;
									}
									break;

								case 'stat':
									if (length(k) > 14 && array_extract(k, 1, 13) == "static_Array_") {
										ensure_funcs();
										parse_extension_method_attrib(gen, "array", k, v, true, 2, funcs, token_get_line(list));
										break;
									}
									if (length(k) > 15 && array_extract(k, 1, 14) == "static_String_") {
										ensure_funcs();
										parse_extension_method_attrib(gen, "string", k, v, true, 0, funcs, token_get_line(list));
										break;
									}
									if (length(k) > 13 && array_extract(k, 1, 12) == "static_Hash_") {
										ensure_funcs();
										parse_extension_method_attrib(gen, "hash", k, v, true, 1 | 2, funcs, token_get_line(list));
										break;
									}
									if (length(k) > 8 && array_extract(k, 1, 7) == "static_") {
										match = true;
									}
									break;

								case 'oper':
									if (length(k) > 10 && array_extract(k, 1, 9) == "operator_") {
										match = true;
									}
									break;
							}
							if (match) {
								return 0, error({script_line(token_get_line(list)), ": undefined class in attribute ", k, " in ", script_name, ".fix"});
							}
						}
					}
				}
				var import_functions = hash_get(functions, import_fname, null);
				if (import_functions) {
					for (var i=0; i<length(import_functions); i++) {
						var (k, v) = hash_entry(import_functions, i);
						if ((v->FUNC_flags & FUNC_FLAG_PRIVATE == 0) && !hash_contains(gen->GEN_imported_functions, k)) {
							gen->GEN_imported_functions{k} = v;
						}
					}
				}
				var import_static_functions = hash_get(static_functions, import_fname, null);
				if (import_static_functions) {
					if (!gen->GEN_imported_static_functions) {
						gen->GEN_imported_static_functions = {};
					}
					for (var i=0; i<length(import_static_functions); i++) {
						var (k, v) = hash_entry(import_static_functions, i);
						if ((v->FUNC_flags & FUNC_FLAG_PRIVATE == 0) && !hash_contains(gen->GEN_imported_static_functions, k)) {
							gen->GEN_imported_static_functions{k} = v;
						}
					}
				}
				var import_instance_functions = hash_get(instance_functions, import_fname, null);
				if (import_instance_functions) {
					if (!gen->GEN_imported_instance_functions) {
						gen->GEN_imported_instance_functions = {};
					}
					for (var i=0; i<length(import_instance_functions); i++) {
						var (k, v) = hash_entry(import_instance_functions, i);
						if ((v->FUNC_flags & FUNC_FLAG_PRIVATE == 0) && !hash_contains(gen->GEN_imported_instance_functions, k)) {
							gen->GEN_imported_instance_functions{k} = v;
						}
					}
				}
				var import_locals = hash_get(locals, import_fname, null);
				if (import_locals) {
					for (var i=0; i<length(import_locals); i++) {
						var (k, v) = hash_entry(import_locals, i);
						if (!v->LOCAL_private) {
							if (!gen->GEN_imported_locals) {
								gen->GEN_imported_locals = {};
							}
							if (!hash_contains(gen->GEN_imported_locals, k)) {
								gen->GEN_imported_locals{k} = v;
							}
						}
					}
				}
				break;
			}

			case KW_CONST: {
				token_expect_next(list);
				if (token_is_symbol(list, '@')) {
					token_expect_next(list);
				}
				if (token_get_type(list) == TOK_IDENT) {
					var name = token_get_value(list);
					token_expect_symbol(list, '=');
					token_expect_next(list);
					if (token_get_type(list) == TOK_IDENT) {
						var alias = token_get_value(list);
						token_expect_next(list);
						if (token_is_symbol(list, ':')) {
							var ia = gen->GEN_import_aliases? hash_get(gen->GEN_import_aliases, alias, null) : null;
							if (!ia) {
								return 0, error({script_line(token_get_line(list)), ": unknown import alias"});
							}
							token_expect_type(list, TOK_IDENT);
							var type = hash_get(ia->IMPORT_ALIAS_consts, token_get_value(list), -1);
							if (type == -1) {
								return 0, error({script_line(token_get_line(list)), ": unknown constant name"});
							}
							gen->GEN_consts{name} = type;
						}
						else {
							token_back(list);
							var type = hash_get(gen->GEN_consts, token_get_value(list), -1);
							if (type == -1) {
								return 0, error({script_line(token_get_line(list)), ": unknown constant name"});
							}
							gen->GEN_consts{name} = type;
						}
					}
					else if (token_get_type(list) == TOK_STRING) {
						gen->GEN_consts{name} = TYPE_STRING;
					}
					else if (token_get_type(list) == '+' || token_get_type(list) == '-') {
						token_expect_next(list);
						if (token_get_type(list) == TOK_FLOAT_NUMBER) {
							gen->GEN_consts{name} = TYPE_FLOAT;
						}
						else {
							gen->GEN_consts{name} = TYPE_INTEGER;
						}
					}
					else if (token_get_type(list) == TOK_FLOAT_NUMBER) {
						gen->GEN_consts{name} = TYPE_FLOAT;
					}
					else {
						gen->GEN_consts{name} = TYPE_INTEGER;
					}
				}
				else if (token_is_symbol(list, '{')) {
					for (;;) {
						token_expect_next(list);
						if (!token_is_symbol(list, '@')) {
							token_back(list);
						}
						token_expect_type(list, TOK_IDENT);
						var name = token_get_value(list);
						gen->GEN_consts{name} = TYPE_INTEGER;
						while (token_next(list)) {
							if (token_is_symbol(list, ',')) break;
							if (token_is_symbol(list, '}')) break;
						}
						if (token_is_symbol(list, '}')) break;
					}
				}
				token_expect_symbol(list, ';');
				break;
			}

			case KW_VAR: {
				if (!parse_locals) {
					parse_locals = [];
				}
				for (;;) {
					var local = object_create(LOCAL_SIZE);
					token_expect_next(list);
					if (token_is_symbol(list, '@')) {
						local->LOCAL_private = true;
					}
					else {
						token_back(list);
					}
					token_expect_type(list, TOK_IDENT);
					local->LOCAL_name = token_get_value(list);
					token_expect_next(list);
					if (token_is_symbol(list, ':')) {
						copy_result_tokens(gen, list);
						local->LOCAL_type = [];
						var start = token_get_pos(list) + TOK_SIZE;
						var level = 0;
						for (;;) {
							token_expect_next(list);
							switch (token_get_type(list)) {
								case '{', '(', '[': level++; continue;
								case '}', ')', ']': level--; continue;
								case ',', ';': if (level == 0) break; continue;
								default: continue;
							}
							break;
						}
						var end = token_get_pos(list);
						if (end-start == 0) {
							return 0, error({script_line(token_get_line(list)), ": missing type"});
						}
						array_append(local->LOCAL_type, list_tokens, start, end-start);
						set_result_copy_start(gen, list);
					}
					parse_locals[] = local;
					if (token_is_symbol(list, ',')) continue;
					break;
				}
				token_back(list);
				token_expect_symbol(list, ';');
				break;
			}

			case TOK_IDENT:
				if (token_has_value(list, "class")) {
					token_set_pos(list, skip_class(gen, token_list(list), false));
					continue;
				}
				if (token_has_value(list, "struct")) {
					token_set_pos(list, skip_class(gen, token_list(list), true));
					continue;
				}
				if (token_has_value(list, "static")) {
					copy_result_tokens(gen, list);
					token_set_pos(list, skip_function(gen, token_list(list), null, FUNC_FLAG_EXTENSION | FUNC_FLAG_STATIC));
					token_next_nocheck(list);
					set_result_copy_start(gen, list);
					token_back(list);
					continue;
				}
				break;

			case KW_FUNCTION: {
				copy_result_tokens(gen, list);
				token_back(list);
				token_set_pos(list, skip_function(gen, token_list(list), null, 0));
				token_next_nocheck(list);
				set_result_copy_start(gen, list);
				token_back(list);
				continue;
			}
		}
	}

	if (parse_locals) {
		for (var i=0; i<length(parse_locals); i++) {
			parse_local(gen, src, parse_locals[i]);
		}
	}
	
	copy_result_tokens(gen, list);

	var parse_classes = gen->GEN_parse_classes;
	for (var i=0; i<length(parse_classes); i+=2) {
		token_set_pos(list, parse_classes[i]);
		parse_class(gen, token_list(list), parse_classes[i+1]);
	}
	array_clear(parse_classes);

	var parse_funcs = gen->GEN_parse_funcs;
	for (var i=0; i<length(parse_funcs); i+=3) {
		token_set_pos(list, parse_funcs[i]);
		var func = parse_funcs[i+2];
		if (func->FUNC_flags & FUNC_FLAG_EXTENSION) {
			if (func->EXTENFUNC_kind == "array") {
				parse_type_allow_generics = 2;
			}
			else if (func->EXTENFUNC_kind == "hash") {
				parse_type_allow_generics = 1 | 2;
			}
			var (r, e) = parse_function(gen, token_list(list), parse_funcs[i+1], func);
			parse_type_allow_generics = 0;
			if (e) return 0, e;
		}
		else {
			parse_function(gen, token_list(list), parse_funcs[i+1], func);
		}
	}
	array_clear(parse_funcs);
}

function @parse_class_attrib(gen, import_fname, name, value, class_attribs, line)
{
	if (!class_attribs) {
		class_attribs = {};
	}

	var map = {};
	var parts = string_split(value, ',');
	for (var i=0; i<length(parts); i++) {
		var parts2 = string_split(parts[i], '=');
		if (length(parts2) != 2) {
			return 0, error({script_line(line), ": invalid value for class attribute ", name});
		}
		map{parts2[0]} = parts2[1];
	}

	var class = object_create(CLASS_SIZE);
	class->CLASS_ext_type = EXT_TYPE_CLASS;
	class->CLASS_name = name;
	class->CLASS_fields = {};
	class->CLASS_functions = {};

	var class_map = hash_get(classes, import_fname, null);
	if (!class_map) {
		class_map = {};
		classes{import_fname} = class_map;
	}
	class_map{name} = class;

	var prefix = hash_get(map, "prefix", null);
	class->CLASS_method_prefix = prefix? {prefix, "_"} : get_method_prefix(class->CLASS_name);

	var struct = hash_get(map, "struct", null);
	class->CLASS_compat_name = struct? struct : get_class_compat_name(prefix? prefix : class->CLASS_name);

	gen->GEN_imported_classes{class->CLASS_name} = class;

	map{0} = class;
	class_attribs{class->CLASS_name} = map;
	return class_attribs;
}

function @finish_class_attribs(gen, class_attribs, consts, funcs)
{
	var sorted = [];

	for (var i=0; i<length(class_attribs); i++) {
		var (name, map) = hash_entry(class_attribs, i);
		var class = map{0};

		var extend = hash_get(map, "extend", null);
		if (extend) {
			class->CLASS_parent = find_class(gen, extend);
		}

		var struct = {class->CLASS_compat_name, "_"};
		for (var j=0; j<length(consts); j++) {
			var (k, v) = hash_entry(consts, j);
			if (k[0] == '@') continue;
			
			if (length(k) > length(struct) && array_extract(k, 0, length(struct)) == struct) {
				var field_name = string_const(k, length(struct), length(k)-length(struct));
				if (field_name == "SIZE") continue;

				var field = object_create(FIELD_SIZE);
				field->FIELD_name = field_name;
				field->FIELD_compat_name = k;
				field->FIELD_type = TYPE_DYNAMIC;
				class->CLASS_fields{field_name} = field;
			}
		}

		var static = hash_get(map, "static", null);
		var static_funcs = {};
		if (static) {
			var list = string_split(static, ':');
			for (var j=0; j<length(list); j++) {
				static_funcs{list[j]} = true;
			}
		}

		var prefix = class->CLASS_method_prefix;
		for (var j=0; j<length(funcs); j++) {
			var (func_name, unused) = hash_entry(funcs, j);
			if (length(func_name) > length(prefix) && array_extract(func_name, 0, length(prefix)) == prefix) {
				func_name = array_extract(func_name, length(prefix), length(func_name)-length(prefix));
				var func_name2;
				var num_params = 0;
				for (var k=length(func_name)-1; k>=0; k--) {
					if (func_name[k] == '#') {
						func_name2 = string_const(func_name, 0, k);
						num_params = string_parse_int(func_name, k+1, length(func_name)-k-1);
						break;
					}
				}

				var func = object_create(FUNC_SIZE);
				func->FUNC_name = func_name2;
				func->FUNC_flags = hash_contains(static_funcs, func_name)? FUNC_FLAG_STATIC : 0;
				func->FUNC_params = {};
				for (var k=0; k<num_params; k++) {
					func->FUNC_params{string_const({"p", k})} = TYPE_DYNAMIC;
				}
				func->FUNC_return_type = TYPE_DYNAMIC;

				class->CLASS_functions{string_const(func_name)} = func;
			}
		}

		var inserted = false;
		for (var j=0; j<length(sorted); j++) {
			if (length(name) > length(sorted[j])) {
				array_insert(sorted, j, name);
				inserted = true;
				break;
			}
		}
		if (!inserted) {
			sorted[] = name;
		}
	}

	var new_attribs = {};
	for (var i=0; i<length(sorted); i++) {
		var name = sorted[i];
		new_attribs{name} = class_attribs{name};
	}

	return new_attribs;
}

function @get_class_from_attribs(class_attribs, cls_name)
{
	var attribs = hash_get(class_attribs, cls_name, null);
	if (attribs) {
		return attribs{0};
	}
	return null;
}

function @adjust_field_attrib_error(fname, line, error, cls_name, field_name)
{
	var prefix = {fname, "(-1): "};
	var msg = error[0];
	if (length(msg) > length(prefix) && array_extract(msg, 0, length(prefix)) == prefix) {
		array_replace_range(msg, 0, length(prefix)-2, script_line(line));
		array_append(msg, {" (for field attribute ", field_name, " in ", cls_name, ")"});
	}
	return error;
}

function @parse_field_attrib(gen, cls_name, field_name, value, class_attribs, line)
{
	var src = {""};
	var tokens = tokens_parse([], src, value, -1);
	token_list_declare(&list, tokens, src);
	var (type, pos) = parse_type_func(gen, token_list(list), false, false);
	if (!is_int(pos)) return 0, pos;
	if (pos != length(tokens)) {
		return 0, error({script_line(line), ": parse error in field attribute ", field_name, " in ", cls_name});
	}
	var class = get_class_from_attribs(class_attribs, cls_name);
	if (!class) {
		// TODO: not really detected
		return 0, error({script_line(line), ": class not found for field attribute ", field_name, " in ", cls_name});
	}
	var field = hash_get(class->CLASS_fields, field_name, null);
	if (!field) {
		return 0, error({script_line(line), ": no field found for attribute ", field_name, " in ", cls_name});
	}
	field->FIELD_type = type;
}

function @adjust_method_attrib_error(fname, line, error, cls_name, method_name)
{
	var prefix = {fname, "(-1): "};
	var msg = error[0];
	if (length(msg) > length(prefix) && array_extract(msg, 0, length(prefix)) == prefix) {
		array_replace_range(msg, 0, length(prefix)-2, script_line(line));
		if (cls_name) {
			array_append(msg, {" (for method attribute ", method_name, " in ", cls_name, ")"});
		}
		else {
			array_append(msg, {" (for global function attribute ", method_name, ")"});
		}
	}
	return error;
}

function @parse_method_attrib(gen, cls_name, method_name, value, class_attribs, is_static, is_extension, funcs, line)
{
	var src = {""};
	var tokens = tokens_parse([], src, value, -1);
	token_list_declare(&list, tokens, src);

	var param_types = [];
	var ret_type = TYPE_DYNAMIC;
	
	token_expect_symbol(list, '(');
	token_expect_next(list);
	if (!token_is_symbol(list, ')')) {
		token_back(list);
		for (;;) {
			var (type, pos) = parse_type_func(gen, token_list(list), false, true);
			if (!is_int(pos)) return 0, pos;
			token_set_pos(list, pos);
			param_types[] = type;

			token_expect_next(list);
			if (token_is_symbol(list, ')')) break;
			if (token_is_symbol(list, ',')) {
				continue;
			}
			if (cls_name) {
				return 0, error({script_line(line), ": parse error in method attribute ", method_name, " in ", cls_name});
			}
			else {
				return 0, error({script_line(line), ": parse error in global function attribute ", method_name});
			}
		}
	}
	if (token_next(list)) {
		token_back(list);
		token_expect_symbol(list, ':');

		var (type, pos) = parse_type_func(gen, token_list(list), true, false);
		if (!is_int(pos)) return 0, pos;
		token_set_pos(list, pos);
		ret_type = type;
	}

	if (token_get_pos(list) != length(tokens)) {
		if (cls_name) {
			return 0, error({script_line(line), ": parse error in method attribute ", method_name, " in ", cls_name});
		}
		else {
			return 0, error({script_line(line), ": parse error in global function attribute ", method_name});
		}
	}

	var func;

	if (cls_name) {
		if (is_extension) {
			func = object_create(EXTENFUNC_SIZE);
			func->FUNC_params = {};
		}
		else {
			var class = get_class_from_attribs(class_attribs, cls_name);
			if (!class) {
				// TODO: not really detected
				return 0, error({script_line(line), ": class not found for method attribute ", method_name, " in ", cls_name});
			}
			func = hash_get(class->CLASS_functions, method_name, null);
			if (!func) {
				return 0, error({script_line(line), ": method not found for method attribute ", method_name, " in ", cls_name});
			}
		}
	}
	else {
		if (!hash_contains(funcs, method_name)) {
			return 0, error({script_line(line), ": global function not found for attribute ", method_name});
		}
		func = object_create(FUNC_SIZE);
		func->FUNC_params = {};
		if (!hash_contains(gen->GEN_imported_functions, method_name)) {
			gen->GEN_imported_functions{method_name} = func;
		}
	}

	var declared_num_params = -1;
	for (var i=length(method_name)-1; i>=0; i--) {
		if (method_name[i] == '#') {
			declared_num_params = string_parse_int(method_name, i+1, length(method_name)-i-1);
		}
	}

	if (is_static) {
		func->FUNC_flags |= FUNC_FLAG_STATIC;
	}
	if ((func->FUNC_flags & FUNC_FLAG_STATIC) == 0) {
		array_insert(param_types, 0, TYPE_DYNAMIC);
	}
	if (cls_name) {
		if (length(param_types) != declared_num_params || (!is_extension && length(param_types) != length(func->FUNC_params))) {
			return 0, error({script_line(line), ": incorrect number of parameters in method attribute ", method_name, " in ", cls_name});
		}
	}
	else {
		if (length(param_types) != declared_num_params) {
			return 0, error({script_line(line), ": incorrect number of parameters in global function attribute ", method_name});
		}
	}
	for (var i=0; i<length(param_types); i++) {
		func->FUNC_params{string_const({"p", i})} = param_types[i];
	}
	func->FUNC_return_type = ret_type;
	return func;
}

function @parse_extension_method_attrib(gen, kind, attrib_name, attrib_value, is_static, allow_generics, funcs, line)
{
	var cnt = 0;
	var class_idx = -1;
	var func_idx = -1;
	for (var i=0; i<length(attrib_name); i++) {
		if (attrib_name[i] == '_') {
			cnt++;
			if (cnt == 1) {
				class_idx = i+1;
			}
			if (cnt == 2) {
				func_idx = i+1;
				break;
			}
		}
	}
	var cls_name = array_extract(attrib_name, class_idx, func_idx-class_idx-1);
	var func_name = array_extract(attrib_name, func_idx, length(attrib_name)-func_idx);
	for (var i=length(func_name)-1; i>=0; i--) {
		if (func_name[i] == '_') {
			func_name[i] = '#';
			break;
		}
	}
	parse_type_allow_generics = allow_generics;
	var (func, e) = parse_method_attrib(gen, cls_name, func_name, attrib_value, null, is_static, true, funcs, line);
	parse_type_allow_generics = 0;
	if (e) {
		return 0, adjust_method_attrib_error(gen->GEN_fname, line, e, cls_name, func_name);
	}

	var full_name = {kind, "_", func_name};
	var plain_name = {full_name};
	for (var i=length(plain_name)-1; i>=0; i--) {
		if (plain_name[i] == '#') {
			array_set_length(plain_name, i);
			break;
		}
	}
	
	func->FUNC_name = plain_name;
	func->FUNC_flags |= FUNC_FLAG_EXTENSION;
	func->EXTENFUNC_kind = kind;

	if (is_static) {
		if (!gen->GEN_imported_static_functions) {
			gen->GEN_imported_static_functions = {};
		}
		if (!hash_contains(gen->GEN_imported_static_functions, full_name)) {
			gen->GEN_imported_static_functions{full_name} = func;
		}
	}
	else {
		if (!gen->GEN_imported_instance_functions) {
			gen->GEN_imported_instance_functions = {};
		}
		if (!hash_contains(gen->GEN_imported_instance_functions, full_name)) {
			gen->GEN_imported_instance_functions{full_name} = func;
		}
	}
}

function @adjust_operator_attrib_error(fname, line, error, cls_name, op_name)
{
	var prefix = {fname, "(-1): "};
	var msg = error[0];
	if (length(msg) > length(prefix) && array_extract(msg, 0, length(prefix)) == prefix) {
		array_replace_range(msg, 0, length(prefix)-2, script_line(line));
		array_append(msg, {" (for operator attribute ", op_name, " in ", cls_name, ")"});
	}
	return error;
}

function @parse_operator_attrib(gen, cls_name, op_name, value, class_attribs, funcs, line)
{
	var class = get_class_from_attribs(class_attribs, cls_name);
	if (!class) {
		return 0, error({script_line(line), ": class not found for operator attribute ", op_name, " in ", cls_name});
	}
	if (length(op_name) == 0) {
		return 0, error({script_line(line), ": empty operator name for operator attribute in ", cls_name});
	}

	var prio = -1;
	var ret_type = class;
	var single_param = false;

	switch (op_name[0]) {
		case 'a':
			if (op_name == "add") { prio = PRIO_ADDITIVE_ADD; break; }
			if (op_name == "and") { prio = PRIO_BITWISE_AND; break; }
			if (op_name == "add_inplace") { prio = PRIO_SPECIAL_ADD_INPLACE; single_param = true; break; }
			if (op_name == "and_inplace") { prio = PRIO_SPECIAL_AND_INPLACE; single_param = true; break; }
			break;

		case 'c':
			if (op_name == "cmp") { prio = PRIO_SPECIAL_COMPARE; ret_type = TYPE_INTEGER; break; }
			break;

		case 'd':
			if (op_name == "div") { prio = PRIO_MULTIPLICATIVE_DIV; break; }
			if (op_name == "div_inplace") { prio = PRIO_SPECIAL_DIV_INPLACE; single_param = true; break; }
			break;

		case 'e':
			if (op_name == "eq") { prio = PRIO_EQUALITY_EQ_VALUE; ret_type = TYPE_BOOLEAN; break; }
			break;

		case 'g':
			if (op_name == "gt") { prio = PRIO_COMPARISON_GT; ret_type = TYPE_BOOLEAN; break; }
			if (op_name == "ge") { prio = PRIO_COMPARISON_GE; ret_type = TYPE_BOOLEAN; break; }
			break;

		case 'l':
			if (op_name == "lt") { prio = PRIO_COMPARISON_LT; ret_type = TYPE_BOOLEAN; break; }
			if (op_name == "le") { prio = PRIO_COMPARISON_LE; ret_type = TYPE_BOOLEAN; break; }
			break;

		case 'm':
			if (op_name == "mul") { prio = PRIO_MULTIPLICATIVE_MUL; break; }
			if (op_name == "mul_inplace") { prio = PRIO_SPECIAL_MUL_INPLACE; single_param = true; break; }
			break;

		case 'n':
			if (op_name == "ne") { prio = PRIO_EQUALITY_NE_VALUE; ret_type = TYPE_BOOLEAN; break; }
			break;

		case 'o':
			if (op_name == "or") { prio = PRIO_BITWISE_OR; break; }
			if (op_name == "or_inplace") { prio = PRIO_SPECIAL_OR_INPLACE; single_param = true; break; }
			break;

		case 'r':
			if (op_name == "rem") { prio = PRIO_MULTIPLICATIVE_REM; break; }
			if (op_name == "rem_inplace") { prio = PRIO_SPECIAL_REM_INPLACE; single_param = true; break; }
			break;

		case 's':
			if (op_name == "sub") { prio = PRIO_ADDITIVE_SUB; break; }
			if (op_name == "shl") { prio = PRIO_BITWISE_SHL; break; }
			if (op_name == "shr") { prio = PRIO_BITWISE_SHR; break; }
			if (op_name == "sub_inplace") { prio = PRIO_SPECIAL_SUB_INPLACE; single_param = true; break; }
			if (op_name == "shl_inplace") { prio = PRIO_SPECIAL_SHL_INPLACE; single_param = true; break; }
			if (op_name == "shr_inplace") { prio = PRIO_SPECIAL_SHR_INPLACE; single_param = true; break; }
			break;

		case 'u':
			if (op_name == "ushr") { prio = PRIO_BITWISE_USHR; break; }
			if (op_name == "ushr_inplace") { prio = PRIO_SPECIAL_USHR_INPLACE; single_param = true; break; }
			break;

		case 'x':
			if (op_name == "xor") { prio = PRIO_BITWISE_XOR; break; }
			if (op_name == "xor_inplace") { prio = PRIO_SPECIAL_XOR_INPLACE; single_param = true; break; }
			break;
	}

	if (prio == -1) {
		return 0, error({script_line(line), ": unknown operator name for operator attribute ", op_name, " in ", cls_name});
	}

	var src = {""};
	var tokens = tokens_parse([], src, value, -1);
	token_list_declare(&list, tokens, src);
	token_expect_type(list, TOK_IDENT);
	var func_name = token_get_value(list);
	token_expect_symbol(list, '(');
	var op1_type, op2_type, pos;
	if (single_param) {
		op1_type = class;
	}
	else {
		(op1_type, pos) = parse_type_func(gen, token_list(list), false, false);
		if (!is_int(pos)) return 0, pos;
		token_set_pos(list, pos);
		token_expect_symbol(list, ',');
	}
	(op2_type, pos) = parse_type_func(gen, token_list(list), false, false);
	if (!is_int(pos)) return 0, pos;
	token_set_pos(list, pos);
	token_expect_symbol(list, ')');
	if (token_get_pos(list)+TOK_SIZE != length(tokens)) {
		return 0, error({script_line(line), ": parse type error for operator attribute ", op_name, " in ", cls_name});
	}
	if (op1_type !== class && op2_type !== class) {
		return 0, error({script_line(line), ": at least one operand must be the owner class type for operator attribute ", op_name, " in ", cls_name});
	}

	func_name = {class->CLASS_method_prefix, func_name};
	if (!hash_contains(funcs, {func_name, "#2"})) {
		return 0, error({script_line(line), ": function ", func_name, " not found for operator attribute ", op_name, " in ", cls_name});
	}

	if (!class->CLASS_operators) {
		class->CLASS_operators = {};
	}
	if (register_operator(class->CLASS_operators, prio, op1_type, op2_type, ret_type, func_name, false, false)) {
		return 0, error({script_line(line), ": duplicate operator attribute ", op_name, " in ", cls_name});
	}
	
	register_operator(gen->GEN_imported_operators, prio, op1_type, op2_type, ret_type, func_name, false, true);

	if (prio == PRIO_SPECIAL_COMPARE) {
		register_compare_operators(class->CLASS_operators, op1_type, op2_type, func_name);
		register_compare_operators(gen->GEN_imported_operators, op1_type, op2_type, func_name);
	}
}

function @process_float_shorthands(tokens, src)
{
	for (var i=length(tokens)-TOK_SIZE; i>=0; i-=TOK_SIZE) {
		switch (tokens[i]) {
			case '+=f':
			case '-=f':
			case '*=f':
			case '/=f': {
				var var_name = null;
				var after = "";
				var remove_semicolon = false;
				var token_before = tokens[i-TOK_SIZE];
				switch (token_before) {
					case TOK_IDENT:
						if (tokens[i-TOK_SIZE*2] == '->') {
							var outer_var = {"__classes_tmp_", tmp_cnt++};
							var field_name = array_extract(src, tokens[i-TOK_SIZE+TOK_off], tokens[i-TOK_SIZE+TOK_len]);

							var start_pos = find_shorthand_start(tokens, src, i-TOK_SIZE*2);
							if (start_pos == i-TOK_SIZE*3 && tokens[i-TOK_SIZE*3] == TOK_IDENT) {
								var outer_name = array_extract(src, tokens[i-TOK_SIZE*3+TOK_off], tokens[i-TOK_SIZE*3+TOK_len]);
								var_name = {outer_name, "->", field_name};
							}
							else {
								var new_tokens = tokens_parse([], src, {"{var ", outer_var, "="}, tokens[i+TOK_line]);
								array_insert_array(tokens, start_pos, new_tokens);
								i += length(new_tokens);

								array_clear(new_tokens);
								tokens_parse(new_tokens, src, {";", outer_var}, tokens[i+TOK_line]);
								array_insert_array(tokens, i-TOK_SIZE*2, new_tokens);
								i += length(new_tokens);

								var_name = {outer_var, "->", field_name};
								after = ";}";
								remove_semicolon = true;
							}
						}
						else {
							var off = i-TOK_SIZE;
							var_name = array_extract(src, tokens[off+TOK_off], tokens[off+TOK_len]);
						}
						break;

					case ']':
					case '}': {
						var is_hash = token_before == '}';
						var outer_var = {"__classes_tmp_", tmp_cnt++};
						var index_var = {"__classes_tmp_", tmp_cnt++};
						var index_start = find_shorthand_index_start(tokens, src, i);
						var start_pos = find_shorthand_start(tokens, src, index_start);

						var new_tokens = tokens_parse([], src, {"{var ", outer_var, "="}, tokens[i+TOK_line]);
						array_insert_array(tokens, start_pos, new_tokens);
						index_start += length(new_tokens);
						i += length(new_tokens);

						array_clear(new_tokens);
						tokens_parse(new_tokens, src, {",", index_var, "="}, tokens[i+TOK_line]);
						array_insert_array(tokens, index_start, new_tokens);
						i += length(new_tokens);
						array_remove(tokens, i-TOK_SIZE, TOK_SIZE);
						array_remove(tokens, index_start+TOK_SIZE*3, TOK_SIZE);
						i -= TOK_SIZE*2;

						array_clear(new_tokens);
						tokens_parse(new_tokens, src, {";", outer_var, is_hash? "{":"[", index_var, is_hash? "}":"]"}, tokens[i+TOK_line]);
						array_insert_array(tokens, i, new_tokens);
						i += length(new_tokens);

						var_name = {outer_var, is_hash? "{":"[", index_var, is_hash? "}":"]"};
						after = ";}";
						remove_semicolon = true;
						break;
					}

					default:
						return 0, error({script_line(tokens[i+TOK_line]), ": invalid assignment destination"});
						break;
				}

				var end_pos = find_shorthand_end(tokens, src, i);
				var off = length(src);

				if (remove_semicolon && tokens[end_pos] == ';') {
					array_remove(tokens, end_pos, TOK_SIZE);
				}

				var append = tokens_parse([], src, {")}", after}, tokens[end_pos-TOK_SIZE+TOK_line]);
				array_insert_array(tokens, end_pos, append);

				var s = {"={(", var_name, ")"};
				s[] = tokens[i] & 0xFF;
				s[] = '(';
				var prepend = tokens_parse([], src, s, tokens[i+TOK_line]);
				array_replace_range(tokens, i, i+TOK_SIZE, prepend);
				break;
			}
		}
	}
}

function @find_shorthand_start(tokens, src, i)
{
	var level = 0;
	i -= TOK_SIZE;
	for (; i >= 0; i -= TOK_SIZE) {
		switch (tokens[i]) {
			case ')', '}', ']':
				level++;
				break;
			case '(', '{', '[':
				if (level == 0) {
					return i + TOK_SIZE;
				}
				level--;
				break;
			case TOK_IDENT:
			case '->':
				continue;
			default:
				if (level == 0) {
					return i + TOK_SIZE;
				}
		}
	}
	return 0;
}

function @find_shorthand_index_start(tokens, src, i)
{
	var level = 0;
	for (; i >= 0; i -= TOK_SIZE) {
		switch (tokens[i]) {
			case ')', '}', ']':
				level++;
				break;
			case '(', '{', '[':
				if (level == 1) {
					return i;
				}
				level--;
				break;
		}
	}
	return 0, error("shouldn't happen");
}

function @find_shorthand_end(tokens, src, i)
{
	var level = 0;
	i += TOK_SIZE;
	for (; i < length(tokens); i += TOK_SIZE) {
		switch (tokens[i]) {
			case '(', '{', '[':
				level++;
				break;
			case ')', '}', ']':
				if (level == 0) {
					return i;
				}
				level--;
				break;
			case ',', ';':
				if (level == 0) {
					return i;
				}
				break;
		}
	}
	return i;
}

function @string_split(s, c)
{
	var result = [];
	var last = 0;
	for (var i=0; i<length(s); i++) {
		if (s[i] == c) {
			result[] = array_extract(s, last, i-last);
			last = i+1;
		}
	}
	if (last < length(s)) {
		result[] = array_extract(s, last, length(s)-last);
	}
	return result;
}

function @get_class_compat_name(name)
{
	var s = {""};
	for (var i=0; i<length(name); i++) {
		var c = name[i];
		switch (c) {
			case 'a'..'z':
				s[] = c - 'a' + 'A';
				continue;
			default:
				s[] = c;
				continue;
		}
	}
	return s;
}

function @get_method_prefix(name)
{
	var s = {""};
	for (var i=0; i<length(name); i++) {
		var c = name[i];
		switch (c) {
			case 'A'..'Z':
				if (i > 0) {
					if ((i+1 < length(name) && name[i+1] >= 'a' && name[i+1] <= 'z')) {
						var c1 = i >= 2? name[i-2] : 0;
						var c2 = i >= 1? name[i-1] : 0;
						var match1 = (c1 == 0 || (c1 >= 'a' && c1 <= 'z'));
						var match2 = (c2 >= 'A' && c2 <= 'Z');
						if (!match1 || !match2) {
							s[] = '_';
						}
					}
					else if ((name[i-1] >= 'a' && name[i-1] <= 'z')) {
						s[] = '_';
					}
				}
				s[] = c - 'A' + 'a'; 
				break;

			default:
				s[] = c;
				break;
		}
	}
	s[] = '_';
	return s;
}

function @find_class(gen, name)
{
	var cls = hash_get(gen->GEN_classes, name, null);
	if (!cls) {
		cls = hash_get(gen->GEN_imported_classes, name, null);
	}
	return cls;
}

function @find_function(gen, name)
{
	var func = hash_get(gen->GEN_functions, name, null);
	if (!func) {
		func = hash_get(gen->GEN_imported_functions, name, null);
		if (!func) {
			func = hash_get(builtin_functions, name, null);
		}
	}
	return func;
}

macro @_parse_type(&ret, list, allow_void, allow_multiple, before_code, after_code)
{
	token_expect_next(list);
	before_code
	var ($ret, $pos) = parse_type_inner(gen, token_list(list), allow_void, allow_multiple);
	after_code
	if (!is_int($pos)) return 0, $pos;
	token_set_pos(list, $pos);
	ret = $ret;
}

macro @parse_type(&ret, list)
{
	_parse_type(&ret, list, false, false, /* nothing */, /* nothing */);
}

macro @parse_type_with_void(&ret, list, allow_generics)
{
	_parse_type(&ret, list, true, false, { parse_type_allow_generics = allow_generics; }, { parse_type_allow_generics = 0; });
}

macro @parse_type_with_multiple(&ret, list, allow_generics)
{
	_parse_type(&ret, list, false, true, { parse_type_allow_generics = allow_generics; }, { parse_type_allow_generics = 0; });
}

function @parse_type_func(gen, token_list(list), allow_void, allow_multiple)
{
	token_expect_next(list);
	var (ret, pos) = parse_type_inner(gen, token_list(list), allow_void, allow_multiple);
	return ret, pos;
}

function @parse_type_inner(gen, token_list(list), allow_void, allow_multiple)
{
	var line = token_get_line(list);
	var type = -1;

	var tok_type = list_tokens[list_off];
	if (tok_type == '[') {
		token_expect_type(list, TOK_IDENT);
		var name = token_get_value(list);
		var struct_type = TYPE_DYNAMIC;
		if (name != "Dynamic") {
			struct_type = find_class(gen, name);
			if (!struct_type) {
				return 0, error({script_line(line), ": can't find struct ", name});
			}
			if (struct_type->CLASS_ext_type != EXT_TYPE_STRUCT) {
				return 0, error({script_line(line), ": must be struct"});
			}
		}
		token_expect_symbol(list, ']');
		
		type = create_array_type(struct_type);
		type->ARRAY_ext_type = EXT_TYPE_STRUCT_ARRAY;
	}
	else {
		if (tok_type != TOK_IDENT) {
			return 0, error({script_line(list_tokens[list_off+TOK_line]), ": expected identifier"});
		}

		var name = token_get_value(list);
		switch (length(name)) {
			case 3:
				if (name == "Key" && (parse_type_allow_generics & 1)) {
					type = TYPE_KEY;
					break;
				}
				break;

			case 4:
				if (name == "Void") {
					if (!allow_void) {
						return 0, error({script_line(line), ": type Void not allowed"});
					}
					type = TYPE_VOID;
					break;
				}
				if (name == "Byte") { type = TYPE_INTEGER; break; }
				break;

			case 5:
				if (name == "Float") { type = TYPE_FLOAT; break; }
				if (name == "Short") { type = TYPE_INTEGER; break; }
				if (name == "Value" && (parse_type_allow_generics & 2)) {
					type = TYPE_VALUE;
					break;
				}
				break;

			case 6:
				if (name == "String") { type = TYPE_STRING; break; }
				break;

			case 7:
				if (name == "Integer") { type = TYPE_INTEGER; break; }
				if (name == "Dynamic") { type = TYPE_DYNAMIC; break; }
				if (name == "Boolean") { type = TYPE_BOOLEAN; break; }
				break;
		}
		if (type == -1) {
			type = find_class(gen, name);
			if (!type) {
				return 0, error({script_line(line), ": can't find class ", name});
			}
		}
	}

	while (token_next(list)) {
		if (token_get_type(list) == '[') {
			token_expect_next(list);
			if (token_is_symbol(list, ']')) {
				if (type == TYPE_VOID) {
					return 0, error({script_line(line), ": can't create array of Void"});
				}
				type = create_array_type(type);
				continue;
			}
			token_back(list);
			if (type == TYPE_VOID) {
				return 0, error({script_line(line), ": can't create hash table with Void type"});
			}
			var index_type;
			parse_type(&index_type, list);
			token_expect_symbol(list, ']');
			type = create_hash_type(type, index_type);
			continue;
		}
		token_back(list);
		break;
	}

	if (allow_multiple && token_next(list)) {
		if (token_is_ident(list, "or")) {
			type = [EXT_TYPE_MULTIPLE, type];
			for (;;) {
				token_expect_next(list);
				var (ret, pos) = parse_type_inner(gen, token_list(list), allow_void, false);
				if (!is_int(pos)) return 0, pos;
				token_set_pos(list, pos);
				type[] = ret;
				if (!token_next(list)) break;
				if (!token_is_ident(list, "or")) {
					token_back(list);
					break;
				}
			}
		}
		else {
			token_back(list);
		}
	}
	
	return type, token_get_pos(list);
}

function @create_array_type(base_type)
{
	var array = object_create(ARRAY_SIZE);
	array->ARRAY_ext_type = EXT_TYPE_ARRAY;
	array->ARRAY_base_type = base_type;
	return array;
}

function @create_hash_type(base_type, index_type)
{
	var hash = object_create(HASH_SIZE);
	hash->HASH_ext_type = EXT_TYPE_HASH;
	hash->HASH_base_type = base_type;
	hash->HASH_index_type = index_type;
	return hash;
}

function @parse_local(gen, src, local)
{
	if (local->LOCAL_type) {
		token_list_declare(&list, local->LOCAL_type, src);
		parse_type(&local->LOCAL_type, list);
		if (token_get_pos(list) != length(list_tokens)) {
			return 0, error({script_line(token_get_line(list)), ": invalid type declaration"});
		}
	}
	else {
		local->LOCAL_type = TYPE_DYNAMIC;
	}
	if (!gen->GEN_locals) {
		gen->GEN_locals = {};
		locals{gen->GEN_fname} = gen->GEN_locals;
	}
	gen->GEN_locals{local->LOCAL_name} = local;
	
	var list = hash_get(locals, gen->GEN_fname, null);
	if (!list) {
		list = {};
		locals{gen->GEN_fname} = list;
	}
	list{local->LOCAL_name} = local;
}

function @skip_class(gen, token_list(list), struct)
{
	copy_result_tokens(gen, list);
	var start_pos = token_get_pos(list);

	var class = object_create(CLASS_SIZE);
	class->CLASS_ext_type = struct? EXT_TYPE_STRUCT : EXT_TYPE_CLASS;
	class->CLASS_fields = {};
	class->CLASS_functions = {};

	token_expect_next(list);
	if (token_is_symbol(list, '@')) {
		class->CLASS_private = true;
	}
	else {
		token_back(list);
	}
	token_expect_type(list, TOK_IDENT);
	class->CLASS_name = token_get_const_value(list);
	class->CLASS_compat_name = get_class_compat_name(class->CLASS_name);
	class->CLASS_method_prefix = get_method_prefix(class->CLASS_name);

	if (hash_contains(gen->GEN_classes, class->CLASS_name)) {
		return 0, error({script_line(token_get_line(list)), ": duplicate class"});
	}
	gen->GEN_classes{class->CLASS_name} = class;

	gen->GEN_parse_classes[] = token_get_pos(list);
	gen->GEN_parse_classes[] = class;

	var level = 0;
	var found_end = false;

	while (token_next(list)) {
		var type = token_get_type(list);
		if (type == TOK_IDENT && token_get_length(list) == 5 && token_get_symbol1(list) == 's' && token_get_value(list) == "super") {
			token_expect_next(list);
			if (!token_is_symbol(list, ':')) {
				token_back(list);
				var line = token_get_line(list);
				token_expect_symbol(list, '.');
				token_expect_type(list, TOK_IDENT);
				var func_name = token_get_value(list);
				token_expect_symbol(list, '(');
				token_expect_next(list);

				var num_params = 0;
				if (token_is_symbol(list, ')')) {
					token_back(list);
				}
				else {
					token_back(list);
					for (;;) {
						num_params++;
						token_expect_expression(list);
						token_expect_next(list);
						if (token_is_symbol(list, ',')) continue;
						token_back(list);
						break;
					}
				}
				token_expect_symbol(list, ')');

				var name = {func_name, "#", num_params+1};

				if (!class->CLASS_supers) {
					class->CLASS_supers = {};
				}
				if (!hash_contains(class->CLASS_supers, name)) {
					class->CLASS_supers{name} = line;
				}
				continue;
			}
			token_back(list);
		}

		switch (token_get_type(list)) {
			case '{':
				level++;
				continue;

			case '}':
				if (--level == 0) {
					found_end = true;
					break;
				}
				continue;

			default:
				continue;
		}
		break;
	}

	if (!found_end) {
		token_set_pos(list, start_pos);
		return 0, error({script_line(token_get_line(list)), ": unclosed ", struct? "struct" : "class"});
	}

	token_next_nocheck(list);
	set_result_copy_start(gen, list);
	token_back(list);
	return token_get_pos(list);
}

function @parse_class(gen, token_list(list), class)
{
	var line = token_get_line(list);

	token_expect_next(list);
	if (token_is_symbol(list, ':')) {
		var type;
		parse_type(&type, list);
		if (type->CLASS_ext_type != class->CLASS_ext_type) {
			return 0, error({script_line(token_get_line(list)), ": can't mix between classes and structs when extending"});
		}
		class->CLASS_parent = type;
		if (type->CLASS_generate_to_string) {
			class->CLASS_generate_to_string = true;
		}
		else if (has_object_script && type->CLASS_name == "Object") {
			class->CLASS_generate_to_string = true;
		}
	}
	else {
		token_back(list);
	}

	//log({"class=", class});

	token_list_declare(&const_list, gen->GEN_const_tokens, list_src);
	token_add_const(const_list, line);
	token_add(const_list, '{', "{", line);
	gen->GEN_first_const = (class->CLASS_parent !== null);

	token_expect_symbol(list, '{');
	token_set_pos(list, parse_class_body(gen, token_list(list), class));
	//token_expect_symbol(list, '}');

	var supers = class->CLASS_supers;
	if (supers) {
		for (var i=0; i<length(supers); i++) {
			var (name, v) = hash_entry(supers, i);
			var adj_name = {""};
			for (var j=0; j<length(name); j++) {
				if (name[j] == '#') {
					adj_name[] = '_';
					adj_name[] = '_';
					continue;
				}
				adj_name[] = name[j];
			}
			var const_name = {class->CLASS_compat_name, "__super__", adj_name};
			token_add(const_list, TOK_IDENT, const_name, line);
			if (gen->GEN_first_const) {
				token_add(const_list, '=', "=", line);
				token_add_complex(const_list, TOK_IDENT, {class->CLASS_parent->CLASS_compat_name, "_SIZE"}, line);
				gen->GEN_first_const = false;
			}
			token_add(const_list, ',', ",", line);
		}
	}

	token_add_complex(const_list, TOK_IDENT, {class->CLASS_compat_name, "_SIZE"}, line);
	if (gen->GEN_first_const) {
		token_add(const_list, '=', "=", line);
		token_add_complex(const_list, TOK_IDENT, {class->CLASS_parent->CLASS_compat_name, "_SIZE"}, line);
	}
	token_add(const_list, '}', "}", line);
	token_add(const_list, ';', ";", line);

	if (class->CLASS_generate_to_string) {
		var func = hash_get(class->CLASS_functions, "to_string#1", null);
		if (func) {
			class->CLASS_generate_to_string = false;
		}
		else {
			func = object_create(FUNC_SIZE);
			func->FUNC_name = "to_string";
			func->FUNC_flags = FUNC_FLAG_VIRTUAL | FUNC_FLAG_OVERRIDE;
			func->FUNC_params = {"this": class};
			func->FUNC_return_type = TYPE_STRING;
			class->CLASS_functions{"to_string#1"} = func;
			class->CLASS_virtual = true;
			
			var short_name = {class->CLASS_method_prefix, func->FUNC_name};
			var func_name = {short_name, "__vfunc"};
			tokens_parse(gen->GEN_const_tokens, list_src, {"const @function_", short_name, "_", length(func->FUNC_params), " = \"\";"}, line);
			tokens_parse(gen->GEN_const_tokens, list_src, {"const @function_", func_name, "_", length(func->FUNC_params), " = \"", class->CLASS_name, ".", func->FUNC_name, "\";"}, line);

			var prefix = {class->CLASS_compat_name, "_"};
			var s = {"function @", func_name, "(this) {"};
			var fields = class->CLASS_fields;
			if (length(fields) > 0) {
				array_append(s, {"var s = {\"", class->CLASS_name, " {\\n  \"};"});
				for (var i=0; i<length(fields); i++) {
					var (name, field) = hash_entry(fields, i);
					var priv = field->FIELD_private? "@":"";
					array_append(s, {"array_append(s, \"", priv, name, ": \");"});
					var type = field->FIELD_type;
					if (is_int(type)) {
						switch (type) {
							case TYPE_DYNAMIC:
								array_append(s, {"array_append(s, __classes_insert_prefix(to_string(this->", prefix, name, ", true), \"  \"));"});
								break;

							case TYPE_INTEGER:
								array_append(s, {"array_append(s, {this->", prefix, name, "});"});
								break;

							case TYPE_FLOAT:
								array_append(s, {"array_append(s, {{this->", prefix, name, " * 1.0}});"});
								break;

							case TYPE_BOOLEAN:
								array_append(s, {"array_append(s, this->", prefix, name, "? \"true\":\"false\");"});
								break;

							case TYPE_STRING:
								array_append(s, {"array_append(s, this->", prefix, name, "? @to_string(this->", prefix, name, ") : \"null\");"});
								break;

							default:
								return 0, error("unknown type");
						}
					}
					else {
						array_append(s, {"array_append(s, this->", prefix, name, "? __classes_insert_prefix(to_string(this->", prefix, name, ", true), \"  \") : \"null\");"});
					}
					if (i < length(fields)-1) {
						array_append(s, "array_append(s, \",\\n  \");");
					}
				}
				array_append(s, "array_append(s, \"\\n}\");");
				array_append(s, "return s;");
			}
			else {
				array_append(s, {"return \"", class->CLASS_name, " {}\";"});
			}
			array_append(s, "}");
			tokens_parse(gen->GEN_func_tokens, list_src, s, line);
		}
	}

	if (class->CLASS_virtual) {
		append_vfunc_object_create(gen, list_src, class, line, false);
		if (class->CLASS_parent) {
			append_vfunc_object_create(gen, list_src, class, line, true);
		}
	}

	return token_get_pos(list);
}

function @append_vfunc_object_create(gen, list_src, class, line, extend)
{
	token_list_declare(&func_list, gen->GEN_func_tokens, list_src);
	token_add_function(func_list, line);
	token_add(func_list, '@', "@", line);
	if (extend) {
		token_add_complex(func_list, TOK_IDENT, {"vfunc__", class->CLASS_method_prefix, "_object_extend"}, line);
	}
	else {
		token_add_complex(func_list, TOK_IDENT, {"vfunc__", class->CLASS_method_prefix, "_object_create"}, line);
	}
	token_add(func_list, '(', "(", line);
	if (extend) {
		token_add(func_list, TOK_IDENT, "obj", line);
	}
	token_add(func_list, ')', ")", line);
	token_add(func_list, '{', "{", line);
	if (!extend) {
		token_add_var(func_list, line);
	}
	token_add(func_list, TOK_IDENT, "obj", line);
	token_add(func_list, '=', "=", line);
	if (extend) {
		token_add(func_list, TOK_IDENT, "object_extend", line);
	}
	else {
		token_add(func_list, TOK_IDENT, "object_create", line);
	}
	token_add(func_list, '(', "(", line);
	if (extend) {
		token_add(func_list, TOK_IDENT, "obj", line);
		token_add(func_list, ',', ",", line);
	}
	token_add_complex(func_list, TOK_IDENT, {class->CLASS_compat_name, "_SIZE"}, line);
	token_add(func_list, ')', ")", line);
	token_add(func_list, ';', ";", line);
	var supers = class->CLASS_supers;
	if (supers && extend) {
		for (var i=0; i<length(supers); i++) {
			var (func_name, usage_line) = hash_entry(supers, i);
			var func_class = class;
			var func = null;
			for (;;) {
				func_class = func_class->CLASS_parent;
				if (!func_class) {
					var adj_name = {func_name};
					for (var j=length(adj_name)-1; j>=0; j--) {
						if (adj_name[j] == '#') {
							array_set_length(adj_name, j);
							break;
						}
					}
					return 0, error({script_line(usage_line), ": virtual function ", adj_name, " not found in super classes"});
				}

				func = hash_get(func_class->CLASS_functions, func_name, null);
				if (func && (func->FUNC_flags & (FUNC_FLAG_VIRTUAL | FUNC_FLAG_OVERRIDE)) == FUNC_FLAG_VIRTUAL) {
					break;
				}
			}
			tokens_parse(func_list_tokens, func_list_src, {
				"obj->", class->CLASS_compat_name, "__super__", func->FUNC_name, "__", length(func->FUNC_params), " = ",
				"obj->", func_class->CLASS_compat_name, "__vfunc__", func->FUNC_name, "__", length(func->FUNC_params), ";"
			}, line);
		}
	}
	var funcs = class->CLASS_functions;
	for (var i=0; i<length(funcs); i++) {
		var (k, func) = hash_entry(funcs, i);
		if ((func->FUNC_flags & (FUNC_FLAG_VIRTUAL | FUNC_FLAG_ABSTRACT)) == FUNC_FLAG_VIRTUAL) {
			var base_class = class;
			var base_func = func;
			if (func->FUNC_flags & FUNC_FLAG_OVERRIDE) {
				var name = {func->FUNC_name, "#", length(func->FUNC_params)};
				base_class = base_class->CLASS_parent;
				base_func = null;
				while (base_class) {
					var f = hash_get(base_class->CLASS_functions, name, null);
					if (f && (f->FUNC_flags & FUNC_FLAG_VIRTUAL) && !(f->FUNC_flags & FUNC_FLAG_OVERRIDE)) {
						base_func = f;
						break;
					}
					base_class = base_class->CLASS_parent;
				}
				if (!base_func) {
					return 0, error({script_line(line), ": can't find base function"});
				}
			}
			token_add(func_list, TOK_IDENT, "obj", line);
			token_add(func_list, '->', "->", line);
			token_add_complex(func_list, TOK_IDENT, {base_class->CLASS_compat_name, "__vfunc__", base_func->FUNC_name, "__", length(base_func->FUNC_params)}, line);
			token_add(func_list, '=', "=", line);
			token_add_complex(func_list, TOK_FUNC_REF, {class->CLASS_method_prefix, func->FUNC_name, "__vfunc#", length(func->FUNC_params)}, line);
			token_add(func_list, ';', ";", line);
		}
	}
	token_add_return(func_list, line);
	token_add(func_list, TOK_IDENT, "obj", line);
	token_add(func_list, ';', ";", line);
	token_add(func_list, '}', "}", line);
}

function @parse_class_body(gen, token_list(list), class)
{
	token_list_declare(&const_list, gen->GEN_const_tokens, list_src);

	while (token_next(list)) {
		switch (token_get_type(list)) {
			case KW_VAR: {
				var field = object_create(FIELD_SIZE);
				token_expect_next(list);
				var line = token_get_line(list);
				if (token_is_symbol(list, '@')) {
					field->FIELD_private = true;
					token_add(const_list, '@', "@", line);
				}
				else {
					token_back(list);
				}
				token_expect_type(list, TOK_IDENT);
				field->FIELD_name = token_get_const_value(list);
				field->FIELD_compat_name = {class->CLASS_compat_name, "_", field->FIELD_name};
				token_add_complex(const_list, TOK_IDENT, field->FIELD_compat_name, line);
				if (gen->GEN_first_const) {
					token_add(const_list, '=', "=", line);
					token_add_complex(const_list, TOK_IDENT, {class->CLASS_parent->CLASS_compat_name, "_SIZE"}, line);
					gen->GEN_first_const = false;
				}
				token_add(const_list, ',', ",", line);

				token_expect_next(list);
				if (token_is_symbol(list, ':')) {
					parse_type(&field->FIELD_type, list);
				}
				else {
					token_back(list);
				}
				token_expect_symbol(list, ';');
				class->CLASS_fields{field->FIELD_name} = field;
				continue;
			}

			case TOK_IDENT: {
				var line = token_get_line(list);
				var ident = token_get_value(list);
				var flags = 0;
				if (ident == "static") {
					flags = FUNC_FLAG_STATIC;
				}
				else if (ident == "virtual") {
					if (class->CLASS_ext_type == EXT_TYPE_STRUCT) {
						return 0, error({script_line(token_get_line(list)), ": virtual functions can't be used in structs"});
					}
					flags = FUNC_FLAG_VIRTUAL;
				}
				else if (ident == "override") {
					if (class->CLASS_ext_type == EXT_TYPE_STRUCT) {
						return 0, error({script_line(token_get_line(list)), ": virtual functions can't be used in structs"});
					}
					flags = FUNC_FLAG_VIRTUAL | FUNC_FLAG_OVERRIDE;
				}
				else if (ident == "constructor") {
					if (class->CLASS_ext_type == EXT_TYPE_STRUCT) {
						return 0, error({script_line(token_get_line(list)), ": constructors can't be used in structs"});
					}
					flags = FUNC_FLAG_STATIC | FUNC_FLAG_CONSTRUCTOR;
				}
				else if (ident == "operator") {
					if (class->CLASS_ext_type == EXT_TYPE_STRUCT) {
						return 0, error({script_line(token_get_line(list)), ": operators can't be used in structs"});
					}
					flags = FUNC_FLAG_STATIC | FUNC_FLAG_OPERATOR;
				}
				if (flags) {
					if (!(flags & (FUNC_FLAG_CONSTRUCTOR | FUNC_FLAG_OPERATOR))) {
						token_expect_type(list, KW_FUNCTION);
						token_back(list);
					}
					token_set_pos(list, skip_function(gen, token_list(list), class, flags));
					if (flags & FUNC_FLAG_VIRTUAL) {
						var (k, func) = hash_entry(class->CLASS_functions, length(class->CLASS_functions)-1);
						class->CLASS_virtual = true;

						if (!(flags & FUNC_FLAG_OVERRIDE)) {
							var const_name = {class->CLASS_compat_name, "__vfunc__", func->FUNC_name, "__", length(func->FUNC_params)};
							token_add(const_list, TOK_IDENT, const_name, line);
							if (gen->GEN_first_const) {
								token_add(const_list, '=', "=", line);
								token_add_complex(const_list, TOK_IDENT, {class->CLASS_parent->CLASS_compat_name, "_SIZE"}, line);
								gen->GEN_first_const = false;
							}
							token_add(const_list, ',', ",", line);

							token_list_declare(&func_list, gen->GEN_func_tokens, list_src);
							token_add_function(func_list, line);
							if (func->FUNC_flags & FUNC_FLAG_PRIVATE) {
								token_add(func_list, '@', "@", line);
							}
							token_add_complex(func_list, TOK_IDENT, {class->CLASS_method_prefix, func->FUNC_name}, line);
							token_add(func_list, '(', "(", line);
							var params = func->FUNC_params;
							for (var i=0; i<length(params); i++) {
								if (i > 0) {
									token_add(func_list, ',', ",", line);
								}
								token_add_complex(func_list, TOK_IDENT, {"p", i}, line);
							}
							token_add(func_list, ')', ")", line);
							token_add(func_list, '{', "{", line);
							token_add_return(func_list, line);
							token_add(func_list, TOK_IDENT, "p0", line);
							token_add(func_list, '->', "->", line);
							token_add(func_list, TOK_IDENT, const_name, line);
							token_add(func_list, '(', "(", line);
							for (var i=0; i<length(params); i++) {
								if (i > 0) {
									token_add(func_list, ',', ",", line);
								}
								token_add_complex(func_list, TOK_IDENT, {"p", i}, line);
							}
							token_add(func_list, ')', ")", line);
							token_add(func_list, ';', ";", line);
							token_add(func_list, '}', "}", line);
						}
					}
					continue;
				}
				break;
			}

			case KW_FUNCTION: {
				token_back(list);
				token_set_pos(list, skip_function(gen, token_list(list), class, 0));
				continue;
			}
		}

		if (token_get_type(list) == '}') {
			token_back(list);
			break;
		}

		return 0, error({script_line(token_get_line(list)), ": expected variable or function declaration"});
	}
	return token_get_pos(list);
}

macro @get_operator_key(type1, type2, prio)
{
	add32(mul32(add32(mul32(type1, 31), type2), 31), prio)
}

function @register_operator(operators, prio, op1_type, op2_type, ret_type, func_name, compare, replace)
{
	var key = get_operator_key(op1_type, op2_type, prio);

	var list = hash_get(operators, key, null);
	if (!list) {
		list = [];
		operators{key} = list;
	}

	for (var i=0; i<length(list); i+=OPERATOR_SIZE) {
		if (list[i+OPERATOR_prio] !== prio) continue;
		if (list[i+OPERATOR_type1] !== op1_type) continue;
		if (list[i+OPERATOR_type2] !== op2_type) continue;
		if (replace) {
			list[i+OPERATOR_ret_type] = ret_type;
			list[i+OPERATOR_func_name] = func_name;
			list[i+OPERATOR_compare] = compare;
		}
		return true;
	}

	list[] = prio;
	list[] = op1_type;
	list[] = op2_type;
	list[] = ret_type;
	list[] = func_name;
	list[] = compare;
	return false;
}

function @register_compare_operators(operators, op1_type, op2_type, func_name)
{
	register_operator(operators, PRIO_COMPARISON_LT, op1_type, op2_type, TYPE_BOOLEAN, func_name, true, false);
	register_operator(operators, PRIO_COMPARISON_GT, op1_type, op2_type, TYPE_BOOLEAN, func_name, true, false);
	register_operator(operators, PRIO_COMPARISON_LE, op1_type, op2_type, TYPE_BOOLEAN, func_name, true, false);
	register_operator(operators, PRIO_COMPARISON_GE, op1_type, op2_type, TYPE_BOOLEAN, func_name, true, false);
	register_operator(operators, PRIO_EQUALITY_EQ_VALUE, op1_type, op2_type, TYPE_BOOLEAN, func_name, true, false);
	register_operator(operators, PRIO_EQUALITY_NE_VALUE, op1_type, op2_type, TYPE_BOOLEAN, func_name, true, false);
}

function @merge_operators(dest_operators, src_operators)
{
	for (var i=0; i<length(src_operators); i++) {
		var (key, src_entries) = hash_entry(src_operators, i);
		var dest_entries = hash_get(dest_operators, key, null);
		if (!dest_entries) {
			dest_entries = [];
			dest_operators{key} = dest_entries;
		}
		for (var j=0; j<length(src_entries); j+=OPERATOR_SIZE) {
			var prio = src_entries[j+OPERATOR_prio];
			var type1 = src_entries[j+OPERATOR_type1];
			var type2 = src_entries[j+OPERATOR_type2];
			var added = false;
			for (var l=0; l<length(dest_entries); l+=OPERATOR_SIZE) {
				if (dest_entries[l+OPERATOR_prio] !== prio) continue;
				if (dest_entries[l+OPERATOR_type1] !== type1) continue;
				if (dest_entries[l+OPERATOR_type2] !== type2) continue;

				dest_entries[l+OPERATOR_ret_type] = src_entries[j+OPERATOR_ret_type];
				dest_entries[l+OPERATOR_func_name] = src_entries[j+OPERATOR_func_name];
				dest_entries[l+OPERATOR_compare] = src_entries[j+OPERATOR_compare];
				added = true;
				break;
			}
			if (!added) {
				dest_entries[] = prio;
				dest_entries[] = type1;
				dest_entries[] = type2;
				dest_entries[] = src_entries[j+OPERATOR_ret_type];
				dest_entries[] = src_entries[j+OPERATOR_func_name];
				dest_entries[] = src_entries[j+OPERATOR_compare];
			}
		}
	}
}

function @skip_function(gen, token_list(list), class, flags)
{
	var func = object_create(FUNC_SIZE);
	func->FUNC_params = {};
	func->FUNC_flags = flags;
	func->FUNC_return_type = -1;

	var func_line;
	var has_param_types = false;

	if (flags & FUNC_FLAG_OPERATOR) {
		token_expect_next(list);
		func_line = token_get_line(list);
		var op_str = token_get_value(list);
		var single_param = false;
		var prio;
		switch (token_get_type(list)) {
			case '+':    prio = PRIO_ADDITIVE_ADD; break;
			case '-':    prio = PRIO_ADDITIVE_SUB; break;
			case '*':    prio = PRIO_MULTIPLICATIVE_MUL; break;
			case '/':    prio = PRIO_MULTIPLICATIVE_DIV; break;
			case '%':    prio = PRIO_MULTIPLICATIVE_REM; break;
			case '&':    prio = PRIO_BITWISE_AND; break;
			case '|':    prio = PRIO_BITWISE_OR; break;
			case '^':    prio = PRIO_BITWISE_XOR; break;
			case '<<':   prio = PRIO_BITWISE_SHL; break;
			case '>>':   prio = PRIO_BITWISE_SHR; break;
			case '>>>':  prio = PRIO_BITWISE_USHR; break;
			case '<':    prio = PRIO_COMPARISON_LT; break;
			case '>':    prio = PRIO_COMPARISON_GT; break;
			case '<=': {
				var off = token_get_offset(list);
				token_expect_next(list);
				if (token_get_type(list) == '>' && token_get_offset(list) == off+2) {
					prio = PRIO_SPECIAL_COMPARE;
					op_str = "<=>";
				}
				else {
					token_back(list);
					prio = PRIO_COMPARISON_LE;
				}
				break;
			}
			case '>=':   prio = PRIO_COMPARISON_GE; break;
			case '==':   prio = PRIO_EQUALITY_EQ_VALUE; break;
			case '!=':   prio = PRIO_EQUALITY_NE_VALUE; break;

			case '+=':   prio = PRIO_SPECIAL_ADD_INPLACE; single_param = true; break;
			case '-=':   prio = PRIO_SPECIAL_SUB_INPLACE; single_param = true; break;
			case '*=':   prio = PRIO_SPECIAL_MUL_INPLACE; single_param = true; break;
			case '/=':   prio = PRIO_SPECIAL_DIV_INPLACE; single_param = true; break;
			case '%=':   prio = PRIO_SPECIAL_REM_INPLACE; single_param = true; break;
			case '&=':   prio = PRIO_SPECIAL_AND_INPLACE; single_param = true; break;
			case '|=':   prio = PRIO_SPECIAL_OR_INPLACE; single_param = true; break;
			case '^=':   prio = PRIO_SPECIAL_XOR_INPLACE; single_param = true; break;
			case '<<=':  prio = PRIO_SPECIAL_SHL_INPLACE; single_param = true; break;
			case '>>=':  prio = PRIO_SPECIAL_SHR_INPLACE; single_param = true; break;
			case '>>>=': prio = PRIO_SPECIAL_USHR_INPLACE; single_param = true; break;

			default:
				return 0, error({script_line(token_get_line(list)), ": expected operator +, -, *, /, %, &, |, ^, <<, >>, >>>, <, >, <=, >=, ==, !=, <=>, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>= or >>>="});
		}
		var op1_name, op2_name;
		var op1_type, op2_type;
		token_expect_symbol(list, '(');
		if (single_param) {
			op1_name = "this";
			op1_type = class;
			func->FUNC_flags &= ~FUNC_FLAG_STATIC;
		}
		else {
			token_expect_type(list, TOK_IDENT);
			op1_name = token_get_const_value(list);
			token_expect_symbol(list, ':');
			parse_type(&op1_type, list);
			token_expect_symbol(list, ',');
		}
		token_expect_type(list, TOK_IDENT);
		op2_name = token_get_const_value(list);
		if (op2_name == op1_name) {
			return 0, error({script_line(token_get_line(list)), ": duplicate parameter name"});
		}
		token_expect_symbol(list, ':');
		parse_type(&op2_type, list);
		token_expect_symbol(list, ')');
		//log({"op1=", op1_name, " type=", get_type_name(op1_type)});
		//log({"op2=", op2_name, " type=", get_type_name(op2_type)});
		if (op1_type !== class && op2_type !== class) {
			return 0, error({script_line(token_get_line(list)), ": at least one operand must be the owner class type"});
		}
		func->FUNC_name = {"__classes_operator_", tmp_cnt++};
		func->FUNC_alt_name = {"operator ", op_str};
		func->FUNC_params{op1_name} = op1_type;
		func->FUNC_params{op2_name} = op2_type;
		switch (prio) {
			case PRIO_COMPARISON_LT .. PRIO_COMPARISON_GE:
			case PRIO_EQUALITY_EQ_VALUE .. PRIO_EQUALITY_NE_VALUE:
				func->FUNC_return_type = TYPE_BOOLEAN;
				break;

			case PRIO_SPECIAL_COMPARE:
				func->FUNC_return_type = TYPE_INTEGER;
				break;

			default:
				func->FUNC_return_type = class;
		}

		if (!class->CLASS_operators) {
			class->CLASS_operators = {};
		}
		var func_name = {class->CLASS_method_prefix, func->FUNC_name};

		if (register_operator(class->CLASS_operators, prio, op1_type, op2_type, func->FUNC_return_type, func_name, false, false)) {
			return 0, error({script_line(token_get_line(list)), ": duplicate operator"});
		}
		register_operator(gen->GEN_imported_operators, prio, op1_type, op2_type, func->FUNC_return_type, func_name, false, true);

		if (prio == PRIO_SPECIAL_COMPARE) {
			register_compare_operators(class->CLASS_operators, op1_type, op2_type, func_name);
			register_compare_operators(gen->GEN_imported_operators, op1_type, op2_type, func_name);
		}
	}
	else {
		if (!(flags & FUNC_FLAG_CONSTRUCTOR)) {
			token_expect_type(list, KW_FUNCTION);
		}
		func_line = token_get_line(list);
		token_expect_next(list);
		if (token_is_symbol(list, '@')) {
			func->FUNC_flags |= FUNC_FLAG_PRIVATE;
		}
		else {
			token_back(list);
		}
		token_expect_type(list, TOK_IDENT);
		var func_name = token_get_value(list);
		var extension = false;
		var allow_generics = 0;
		token_expect_next(list);
		if (token_is_symbol(list, ':')) {
			token_expect_symbol(list, ':');
			token_expect_type(list, TOK_IDENT);
			extension = true;
			flags |= FUNC_FLAG_EXTENSION;
		}
		else {
			token_back(list);
		}
		if ((func->FUNC_flags & FUNC_FLAG_EXTENSION) && !extension) {
			return 0, error({script_line(token_get_line(list)), ": invalid static extension function"});
		}
		if (extension) {
			object_extend(func, EXTENFUNC_SIZE);
			if (func_name == "Array") {
				func->EXTENFUNC_kind = "array";
				allow_generics = 2;
			}
			else if (func_name == "String") {
				func->EXTENFUNC_kind = "string";
			}
			else if (func_name == "Hash") {
				func->EXTENFUNC_kind = "hash";
				allow_generics = 1 | 2;
			}
			else {
				return 0, error({script_line(token_get_line(list)), ": invalid extension function"});
			}
			func->FUNC_name = string_const({func->EXTENFUNC_kind, "_", token_get_value(list)});
			func->FUNC_flags |= FUNC_FLAG_EXTENSION;
		}
		else {
			func->FUNC_name = string_const(func_name);
		}

		token_expect_symbol(list, '(');

		if ((flags & FUNC_FLAG_STATIC) == 0) {
			if (class) {
				func->FUNC_params{"this"} = class;
			}
			else if (extension) {
				var this_type;
				if (func->EXTENFUNC_kind == "array") {
					this_type = create_array_type(TYPE_VALUE);
				}
				else if (func->EXTENFUNC_kind == "string") {
					this_type = TYPE_STRING;
				}
				else if (func->EXTENFUNC_kind == "hash") {
					this_type = create_hash_type(TYPE_VALUE, TYPE_KEY);
				}
				func->FUNC_params{"this"} = this_type;
			}
		}

		token_expect_next(list);
		if (!token_is_symbol(list, ')')) {
			token_back(list);
			for (;;) {
				token_expect_type(list, TOK_IDENT);
				var name = token_get_const_value(list);

				var type = null;
				token_expect_next(list);
				if (token_is_symbol(list, ':')) {
					parse_type_with_multiple(&type, list, allow_generics);
					has_param_types = true;
				}
				else {
					token_back(list);
				}

				func->FUNC_params{name} = type;

				token_expect_next(list);
				if (token_is_symbol(list, ',')) {
					continue;
				}
				token_back(list);
				break;
			}
			token_expect_symbol(list, ')');
		}

		token_expect_next(list);
		if (token_is_symbol(list, ':')) {
			if (flags & FUNC_FLAG_CONSTRUCTOR) {
				return 0, error({script_line(token_get_line(list)), ": can't set return type for constructors"});
			}
			parse_type_with_void(&func->FUNC_return_type, list, allow_generics);
			has_param_types = true;
		}
		else {
			token_back(list);
			if (flags & FUNC_FLAG_CONSTRUCTOR) {
				func->FUNC_return_type = class;
			}
		}

		var name = string_const({func->FUNC_name, "#", length(func->FUNC_params)});
		if (class) {
			if (hash_contains(class->CLASS_functions, name)) {
				return 0, error({script_line(token_get_line(list)), ": duplicate function"});
			}
			class->CLASS_functions{name} = func;
		}
		else {
			if (!extension) {
				func->FUNC_flags |= FUNC_FLAG_STATIC;
			}
			if (hash_contains(gen->GEN_functions, name)) {
				return 0, error({script_line(token_get_line(list)), ": duplicate function"});
			}
			gen->GEN_functions{name} = func;
			if (extension) {
				if (func->FUNC_flags & FUNC_FLAG_STATIC) {
					if (!gen->GEN_static_functions) {
						gen->GEN_static_functions = {};
						static_functions{gen->GEN_fname} = gen->GEN_static_functions;
					}
					gen->GEN_static_functions{name} = func;
				}
				else {
					if (!gen->GEN_instance_functions) {
						gen->GEN_instance_functions = {};
						instance_functions{gen->GEN_fname} = gen->GEN_instance_functions;
					}
					gen->GEN_instance_functions{name} = func;
				}
			}
		}
	}

	var level = 0;

	var parse_funcs = gen->GEN_parse_funcs;
	parse_funcs[] = token_get_pos(list);
	parse_funcs[] = class;
	parse_funcs[] = func;

	token_expect_next(list);
	if (token_is_symbol(list, ';')) {
		if (flags & FUNC_FLAG_VIRTUAL) {
			if (flags & FUNC_FLAG_OVERRIDE) {
				return 0, error({script_line(token_get_line(list)), ": empty override function"});
			}
			func->FUNC_flags |= FUNC_FLAG_ABSTRACT;
		}
		if (func->FUNC_return_type == -1) {
			func->FUNC_return_type = TYPE_VOID;
		}
		return token_get_pos(list);
	}
	token_back(list);
	
	var found_end = false;
	var returns_void = class || flags || has_param_types;
	var returns_single_value = false;
	var visited_return = false;
	while (token_next(list)) {
		switch (token_get_type(list)) {
			case '{':
				level++;
				continue;

			case '}':
				if (--level == 0) {
					found_end = true;
					break;
				}
				continue;

			case KW_RETURN:
				if (returns_void || visited_return) {
					continue;
				}
				if (token_next(list)) {
					if (token_get_type(list) == ';') {
						token_back(list);
						visited_return = true;
					}
					else {
						token_back(list);
						token_expect_expression(list);
						if (token_next(list) && token_get_type(list) == ';') {
							returns_single_value = true;
							visited_return = true;
						}
						token_back(list);
					}
				}
				else {
					token_back(list);
				}
				continue;

			default:
				continue;
		}
		break;
	}

	if (!found_end) {
		return 0, error({script_line(func_line), ": unclosed function"});
	}
	if (func->FUNC_return_type == -1) {
		if (returns_void || !returns_single_value) {
			func->FUNC_return_type = TYPE_VOID;
		}
		else {
			func->FUNC_return_type = TYPE_DYNAMIC;
		}
	}
	return token_get_pos(list);
}

function @parse_function(gen, token_list(list), class, func)
{
	var line = token_get_line(list);
	var out = (func->FUNC_flags & FUNC_FLAG_ABSTRACT) == 0;

	token_list_declare(&func_list, gen->GEN_func_tokens, list_src);

	if (out) {
		token_add_function(func_list, line);
	}

	if (func->FUNC_flags & FUNC_FLAG_VIRTUAL) {
		if (out) {
			token_add(func_list, '@', "@", line);
		}
		var short_name = {class->CLASS_method_prefix, func->FUNC_name};
		var func_name = {short_name, "__vfunc"};
		if (out) {
			token_add_complex(func_list, TOK_IDENT, func_name, line);
		}
		tokens_parse(gen->GEN_const_tokens, list_src, {"const @function_", short_name, "_", length(func->FUNC_params), " = \"\";"}, line);
		tokens_parse(gen->GEN_const_tokens, list_src, {"const @function_", func_name, "_", length(func->FUNC_params), " = \"", class->CLASS_name, ".", func->FUNC_name, "\";"}, line);
	}
	else {
		if (func->FUNC_flags & FUNC_FLAG_PRIVATE) {
			token_add(func_list, '@', "@", line);
		}
		if (class) {
			var func_name = {class->CLASS_method_prefix, func->FUNC_name};
			token_add_complex(func_list, TOK_IDENT, func_name, line);
			if (func->FUNC_flags & FUNC_FLAG_STATIC) {
				tokens_parse(gen->GEN_const_tokens, list_src, {"const @function_", func_name, "_", length(func->FUNC_params), " = \"", class->CLASS_name, "::", func->FUNC_alt_name? func->FUNC_alt_name : func->FUNC_name, "\";"}, line);
			}
			else {
				tokens_parse(gen->GEN_const_tokens, list_src, {"const @function_", func_name, "_", length(func->FUNC_params), " = \"", class->CLASS_name, ".", func->FUNC_alt_name? func->FUNC_alt_name : func->FUNC_name, "\";"}, line);
			}
		}
		else {
			token_add_complex(func_list, TOK_IDENT, func->FUNC_name, line);
		}
	}

	if (out) {
		token_add(func_list, '(', "(", line);
	}

	hash_clear(gen->GEN_vars);
	var params = func->FUNC_params;
	for (var i=0; i<length(params); i++) {
		var (k, v) = hash_entry(params, i);
		if (i > 0) {
			if (out) {
				token_add(func_list, ',', ",", line);
			}
		}
		if (out) {
			token_add_complex(func_list, TOK_IDENT, k, line);
		}
		if (is_array(v) && v[0] == EXT_TYPE_MULTIPLE) {
			v = TYPE_DYNAMIC;
		}
		gen->GEN_vars{k} = v;
	}

	if (out) {
		token_add(func_list, ')', ")", line);
	}

	gen->GEN_cur_func = func;
	gen->GEN_cur_class = class;

	token_expect_next(list);
	if (token_is_symbol(list, ';')) {
		if (out) {
			set_func_copy_start(gen, list);
		}
		else {
			token_next_nocheck(list);
			set_func_copy_start(gen, list);
			token_back(list);
		}
	}
	else {
		token_back(list);
	
		token_expect_symbol(list, '{');
		set_func_copy_start(gen, list);
		if (func->FUNC_flags & FUNC_FLAG_CONSTRUCTOR) {
			var parent = class->CLASS_parent;
			if (parent) {
				token_expect_next(list);
				if (token_is_ident(list, "super")) {
					line = token_get_line(list);
					copy_func_tokens(gen, list);
					token_expect_symbol(list, ':');
					token_expect_symbol(list, ':');
					token_expect_type(list, TOK_IDENT);
					var name = token_get_value(list);
					token_expect_symbol(list, '(');
					var pos = length(gen->GEN_func_tokens) - TOK_SIZE;
					if (class->CLASS_virtual) {
						tokens_parse(gen->GEN_func_tokens, list_src, {"var this = vfunc__", class->CLASS_method_prefix, "_object_extend(", parent->CLASS_method_prefix, name}, line);
					}
					else {
						tokens_parse(gen->GEN_func_tokens, list_src, {"var this = object_extend(", parent->CLASS_method_prefix, name}, line);
					}
					set_func_copy_start(gen, list);

					var params_off = token_get_pos(list);
					token_expect_next(list);
				
					var num_params = 0;
					if (token_is_symbol(list, ')')) {
						token_back(list);
					}
					else {
						token_back(list);
						for (;;) {
							num_params++;
							token_expect_expression(list);
							token_expect_next(list);
							if (token_is_symbol(list, ',')) continue;
							token_back(list);
							break;
						}
					}
					token_expect_symbol(list, ')');

					var func_name = {name, "#", num_params};
					var super_func = hash_get(parent->CLASS_functions, func_name, null);
					if (!super_func || !(super_func->FUNC_flags & FUNC_FLAG_STATIC)) {
						return 0, error({script_line(token_get_line(list)), ": static method ", func_name, " not found in ", get_class_name_with_kind(parent)});
					}
				
					token_set_pos(list, params_off);
					for (var i=0; i<num_params; i++) {
						if (i > 0) {
							token_expect_symbol(list, ',');
						}
						var (param_name, param_type) = hash_entry(super_func->FUNC_params, i);
						var param_start_pos = token_get_pos(list);
						token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
						append_type_conv(gen, token_list(list), param_start_pos, param_type, gen->GEN_ret_type);
					}
					token_expect_symbol(list, ')');
					copy_func_tokens(gen, list);
					if (class->CLASS_virtual) {
						tokens_parse(gen->GEN_func_tokens, list_src, ")); {var __classes_padding", line); // TODO
					}
					else {
						tokens_parse(gen->GEN_func_tokens, list_src, {"), ", class->CLASS_compat_name, "_SIZE); {var __classes_padding"}, line); // TODO
					}
					token_expect_symbol(list, ';');
					set_func_copy_start(gen, list);
				}
				else {
					token_back(list);
					var super_func = hash_get(parent->CLASS_functions, "create#0", null);
					if (!super_func || !(super_func->FUNC_flags & FUNC_FLAG_STATIC)) {
						return 0, error({script_line(token_get_line(list)), ": default constructor not found in class ", parent->CLASS_name});
					}
					if (class->CLASS_virtual) {
						tokens_parse(gen->GEN_func_tokens, list_src, {"{var this = vfunc__", class->CLASS_method_prefix, "_object_extend(", parent->CLASS_method_prefix, "create());"}, line);
					}
					else {
						tokens_parse(gen->GEN_func_tokens, list_src, {"{var this = object_extend(", parent->CLASS_method_prefix, "create(), ", class->CLASS_compat_name, "_SIZE);"}, line);
					}
				}
			}
			else {
				if (class->CLASS_virtual) {
					tokens_parse(gen->GEN_func_tokens, list_src, {"{var this=vfunc__", class->CLASS_method_prefix, "_object_create();"}, line);
				}
				else {
					tokens_parse(gen->GEN_func_tokens, list_src, {"{var this=object_create(", class->CLASS_compat_name, "_SIZE);"}, line);
				}
			}
			gen->GEN_vars{"this"} = class;
		}
		token_set_pos(list, parse_block(gen, token_list(list), BT_NORMAL));
	}

	gen->GEN_cur_func = null;
	gen->GEN_cur_class = null;

	token_next_nocheck(list);
	copy_func_tokens(gen, list);

	if (func->FUNC_flags & FUNC_FLAG_CONSTRUCTOR) {
		var pos = length(gen->GEN_func_tokens) - TOK_SIZE;
		line = gen->GEN_func_tokens[pos+TOK_line];
		//array_set_length(gen->GEN_func_tokens, pos);
		tokens_parse(gen->GEN_func_tokens, list_src, "return this; }", line);
	}

	if (func->FUNC_flags & FUNC_FLAG_CONSTRUCTOR) {
		hash_remove(gen->GEN_vars, "this");
	}

	token_back(list);
	return token_get_pos(list);
}

function @parse_block(gen, token_list(list), block_type)
{
	var stack_pos = length(gen->GEN_var_stack);
	var type = -1;

	for (;;) {
		if (block_type == BT_SINGLE && type != -1) {
			return token_get_pos(list);
		}

		if (!token_next(list)) break;
		type = token_get_type(list);

		switch (type) {
			case '{': {
				token_set_pos(list, parse_block(gen, token_list(list), BT_NORMAL));
				continue;
			}

			case '}': {
				for (var i=length(gen->GEN_var_stack)-1; i>=stack_pos; i--) {
					hash_remove(gen->GEN_vars, gen->GEN_var_stack[i]);
				}
				array_set_length(gen->GEN_var_stack, stack_pos);
				return token_get_pos(list);
			}

			case '(': {
				if (token_next(list) && token_get_type(list) == TOK_IDENT) {
					if (token_next(list) && token_is_symbol(list, ',')) {
						token_back(list);
						var var1_type = hash_get(gen->GEN_vars, token_get_value(list), -1);
						if (var1_type == -1) {
							return 0, error({script_line(token_get_line(list)), ": unknown variable ", token_get_value(list)});
						}
						token_next_nocheck(list);
						token_expect_type(list, TOK_IDENT);
						var var2_type = hash_get(gen->GEN_vars, token_get_value(list), -1);
						if (var2_type == -1) {
							return 0, error({script_line(token_get_line(list)), ": unknown variable ", token_get_value(list)});
						}
						token_expect_symbol(list, ')');
						token_expect_symbol(list, '=');
						gen->GEN_hash_entry_value_type = -1;
						token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
						check_implicit_conv_with_error(var1_type, gen->GEN_ret_type, token_get_line(list));
						if (gen->GEN_hash_entry_value_type != -1) {
							check_implicit_conv_with_error(var2_type, gen->GEN_hash_entry_value_type, token_get_line(list));
						}
						gen->GEN_hash_entry_value_type = 0;
						token_expect_symbol(list, ';');
						continue;
					}
					else {
						token_back(list);
						token_back(list);
					}
				}
				else {
					token_back(list);
				}
				break;
			}

			case '=': {
				if (block_type == BT_EXPR) {
					token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
					token_expect_symbol(list, '}');
					for (var i=length(gen->GEN_var_stack)-1; i>=stack_pos; i--) {
						hash_remove(gen->GEN_vars, gen->GEN_var_stack[i]);
					}
					array_set_length(gen->GEN_var_stack, stack_pos);
					return token_get_pos(list);
				}
				break;
			}

			case KW_VAR: {
				if (block_type == BT_SINGLE) {
					return 0, error({script_line(token_get_line(list)), ": declaring variables is not allowed in single statement"});
				}
				if (token_next(list) && token_is_symbol(list, '(')) {
					token_expect_type(list, TOK_IDENT);

					var var1 = token_get_value(list);
					if (hash_contains(gen->GEN_vars, var1)) {
						return 0, error({script_line(token_get_line(list)), ": duplicate variable"});
					}
					var var1_type = -1;
					token_expect_next(list);
					if (token_is_symbol(list, ':')) {
						copy_func_tokens(gen, list);
						parse_type(&var1_type, list);
						token_expect_next(list);
						set_func_copy_start(gen, list);
					}
					token_back(list);

					token_expect_symbol(list, ',');
					token_expect_type(list, TOK_IDENT);

					var var2 = token_get_value(list);
					if (hash_contains(gen->GEN_vars, var2)) {
						return 0, error({script_line(token_get_line(list)), ": duplicate variable"});
					}
					var var2_type = -1;
					token_expect_next(list);
					if (token_is_symbol(list, ':')) {
						copy_func_tokens(gen, list);
						parse_type(&var2_type, list);
						token_expect_next(list);
						set_func_copy_start(gen, list);
					}
					token_back(list);

					token_expect_symbol(list, ')');
					token_expect_symbol(list, '=');
					var start_pos = token_get_pos(list);
					gen->GEN_hash_entry_value_type = -1;
					token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
					if (var1_type == -1) {
						var1_type = gen->GEN_ret_type;
					}
					if (var2_type == -1) {
						var2_type = gen->GEN_hash_entry_value_type;
					}
					if (var1_type == -1) var1_type = TYPE_DYNAMIC;
					if (var2_type == -1) var2_type = TYPE_DYNAMIC;
					check_implicit_conv_with_error(var1_type, gen->GEN_ret_type, token_get_line(list));
					if (gen->GEN_hash_entry_value_type != -1) {
						check_implicit_conv_with_error(var2_type, gen->GEN_hash_entry_value_type, token_get_line(list));
					}
					gen->GEN_hash_entry_value_type = 0;
					token_expect_symbol(list, ';');

					gen->GEN_vars{var1} = var1_type;
					gen->GEN_vars{var2} = var2_type;
					gen->GEN_var_stack[] = var1;
					gen->GEN_var_stack[] = var2;
					continue;
				}
				else {
					token_back(list);
				}
				for (;;) {
					token_expect_type(list, TOK_IDENT);
					var var_name = token_get_value(list);

					var var_type = -1;
					token_expect_next(list);
					if (token_is_symbol(list, ':')) {
						copy_func_tokens(gen, list);
						parse_type(&var_type, list);
						token_expect_next(list);
						set_func_copy_start(gen, list);
					}
					if (token_is_symbol(list, '=')) {
						//log("---");
						var start_pos = token_get_pos(list);
						token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
						append_type_conv(gen, token_list(list), start_pos, var_type, gen->GEN_ret_type);
						token_expect_next(list);
						if (var_type == -1) {
							var_type = gen->GEN_ret_type;
						}
					}
					if (var_type == -1) {
						var_type = TYPE_DYNAMIC;
					}

					if (hash_contains(gen->GEN_vars, var_name)) {
						return 0, error({script_line(token_get_line(list)), ": duplicate variable"});
					}
					gen->GEN_vars{var_name} = var_type;
					gen->GEN_var_stack[] = var_name;

					if (token_is_symbol(list, ',')) {
						continue;
					}
					token_back(list);
					break;
				}

				token_expect_symbol(list, ';');
				continue;
			}

			case KW_RETURN: {
				var ret_type = gen->GEN_cur_func->FUNC_return_type;
				token_expect_next(list);
				if (token_is_symbol(list, ';')) {
					if (gen->GEN_cur_func->FUNC_flags & FUNC_FLAG_CONSTRUCTOR) {
						copy_func_tokens(gen, list);
						tokens_parse(gen->GEN_func_tokens, list_src, "this", token_get_line(list));
						set_func_copy_start(gen, list);
						continue;
					}
					if (ret_type != TYPE_DYNAMIC && ret_type != TYPE_VOID) {
						return 0, error({script_line(token_get_line(list)), ": function requires value to return"});
					}
					continue;
				}
				if (gen->GEN_cur_func->FUNC_flags & FUNC_FLAG_CONSTRUCTOR) {
					return 0, error({script_line(token_get_line(list)), ": cannot return values in constructors"});
				}
				if (ret_type == TYPE_VOID) {
					return 0, error({script_line(token_get_line(list)), ": cannot return value in void function"});
				}
				token_back(list);
				var start_pos = token_get_pos(list);
				token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
				append_type_conv(gen, token_list(list), start_pos, ret_type, gen->GEN_ret_type);
				token_expect_next(list);
				if (token_is_symbol(list, ',')) {
					token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
				}
				else {
					token_back(list);
				}
				token_expect_symbol(list, ';');
				continue;
			}

			case KW_IF: {
				token_expect_symbol(list, '(');
				var start_pos = token_get_pos(list);
				token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
				if (gen->GEN_ret_type == TYPE_INTEGER || gen->GEN_ret_type == TYPE_FLOAT) {
					return 0, error({script_line(token_get_line(list)), ": can't use integer or float in condition"});
				}
				token_expect_symbol(list, ')');
				token_expect_next(list);
				if (token_is_symbol(list, '{')) {
					token_set_pos(list, parse_block(gen, token_list(list), BT_NORMAL));
					token_expect_next(list);
					if (token_get_type(list) == KW_ELSE) {
						token_expect_next(list);
						if (token_is_symbol(list, '{')) {
							token_set_pos(list, parse_block(gen, token_list(list), BT_NORMAL));
						}
						else {
							token_back(list);
							token_set_pos(list, parse_block(gen, token_list(list), BT_SINGLE));
						}
					}
					else {
						token_back(list);
					}
				}
				else {
					token_back(list);
					token_set_pos(list, parse_block(gen, token_list(list), BT_SINGLE));
				}
				continue;
			}

			case KW_WHILE: {
				token_expect_symbol(list, '(');
				var start_pos = token_get_pos(list);
				token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
				if (gen->GEN_ret_type == TYPE_INTEGER || gen->GEN_ret_type == TYPE_FLOAT) {
					return 0, error({script_line(token_get_line(list)), ": can't use integer or float in condition"});
				}
				token_expect_symbol(list, ')');
				token_expect_next(list);
				if (token_is_symbol(list, '{')) {
					token_set_pos(list, parse_block(gen, token_list(list), BT_NORMAL));
				}
				else {
					token_back(list);
					token_set_pos(list, parse_block(gen, token_list(list), BT_SINGLE));
				}
				continue;
			}

			case KW_DO: {
				token_expect_symbol(list, '{');
				token_set_pos(list, parse_block(gen, token_list(list), BT_NORMAL));
				token_expect_type(list, KW_WHILE);
				token_expect_symbol(list, '(');
				var start_pos = token_get_pos(list);
				token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
				if (gen->GEN_ret_type == TYPE_INTEGER || gen->GEN_ret_type == TYPE_FLOAT) {
					return 0, error({script_line(token_get_line(list)), ": can't use integer or float in condition"});
				}
				token_expect_symbol(list, ')');
				token_expect_symbol(list, ';');
				continue;
			}

			case KW_FOR: {
				var for_stack_pos = length(gen->GEN_var_stack);
				token_expect_symbol(list, '(');
				token_expect_next(list);
				if (!token_is_symbol(list, ';')) {
					if (token_get_type(list) == KW_VAR) {
						for (;;) {
							token_expect_type(list, TOK_IDENT);
							var var_name = token_get_value(list);

							var var_type = -1;
							token_expect_next(list);
							if (token_is_symbol(list, ':')) {
								copy_func_tokens(gen, list);
								parse_type(&var_type, list);
								token_expect_next(list);
								set_func_copy_start(gen, list);
							}
							if (token_is_symbol(list, '=')) {
								//log("---");
								var start_pos = token_get_pos(list);
								token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
								append_type_conv(gen, token_list(list), start_pos, var_type, gen->GEN_ret_type);
								token_expect_next(list);
								if (var_type == -1) {
									var_type = gen->GEN_ret_type;
								}
							}
							if (var_type == -1) {
								var_type = TYPE_DYNAMIC;
							}

							if (hash_contains(gen->GEN_vars, var_name)) {
								return 0, error({script_line(token_get_line(list)), ": duplicate variable"});
							}
							gen->GEN_vars{var_name} = var_type;
							gen->GEN_var_stack[] = var_name;

							if (token_is_symbol(list, ',')) {
								continue;
							}
							token_back(list);
							break;
						}
					}
					else {
						token_back(list);
						for (;;) {
							token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
							token_expect_next(list);
							if (token_is_symbol(list, ',')) continue;
							token_back(list);
							break;
						}
					}
				}
				else {
					token_back(list);
				}
				token_expect_symbol(list, ';');

				token_expect_next(list);
				if (!token_is_symbol(list, ';')) {
					token_back(list);
					var start_pos = token_get_pos(list);
					token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
					if (gen->GEN_ret_type == TYPE_INTEGER || gen->GEN_ret_type == TYPE_FLOAT) {
						return 0, error({script_line(token_get_line(list)), ": can't use integer or float in condition"});
					}
				}
				else {
					token_back(list);
				}
				token_expect_symbol(list, ';');

				token_expect_next(list);
				if (!token_is_symbol(list, ')')) {
					token_back(list);
					token_set_pos(list, parse_expression(gen, token_list(list), -2, token_get_pos(list), PRIO_PRIMARY));
				}
				else {
					token_back(list);
				}

				token_expect_symbol(list, ')');
				token_expect_next(list);
				if (token_is_symbol(list, '{')) {
					token_set_pos(list, parse_block(gen, token_list(list), BT_NORMAL));
				}
				else {
					token_back(list);
					token_set_pos(list, parse_block(gen, token_list(list), BT_SINGLE));
				}

				for (var i=length(gen->GEN_var_stack)-1; i>=for_stack_pos; i--) {
					hash_remove(gen->GEN_vars, gen->GEN_var_stack[i]);
				}
				array_set_length(gen->GEN_var_stack, for_stack_pos);
				continue;
			}

			case KW_SWITCH: {
				token_expect_symbol(list, '(');
				var start_pos = token_get_pos(list);
				token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
				append_type_conv(gen, token_list(list), start_pos, TYPE_INTEGER, gen->GEN_ret_type);
				token_expect_symbol(list, ')');
				token_expect_symbol(list, '{');

				var end = false;
				while (!end) {
					token_expect_next(list);
					switch (token_get_type(list)) {
						case KW_CASE: {
							// TODO: add support for class constants
							do {
								token_expect_next(list); // constant
								var name = token_get_value(list);
								token_expect_next(list);
								if (token_is_symbol(list, ':') && gen->GEN_import_aliases && hash_contains(gen->GEN_import_aliases, name)) {
									token_expect_next(list);
									token_expect_next(list);
								}
								if (token_get_type(list) == '..') {
									token_expect_next(list); // constant
									name = token_get_value(list);
									token_expect_next(list);
									if (token_is_symbol(list, ':') && gen->GEN_import_aliases && hash_contains(gen->GEN_import_aliases, name)) {
										token_expect_next(list);
										token_expect_next(list);
									}
								}
							}
							while (token_is_symbol(list, ','));
							token_back(list);
							token_expect_symbol(list, ':');
							break;
						}

						case KW_DEFAULT: {
							token_expect_symbol(list, ':');
							break;
						}

						default: {
							if (token_is_symbol(list, '}')) {
								end = true;
								break;
							}
							if (token_is_symbol(list, '{')) {
								token_set_pos(list, parse_block(gen, token_list(list), BT_NORMAL));
							}
							else {
								token_back(list);
								token_set_pos(list, parse_block(gen, token_list(list), BT_SINGLE));
							}
							break;
						}
					}
				}
				continue;
			}

			case KW_BREAK, KW_CONTINUE: {
				token_expect_symbol(list, ';');
				continue;
			}

			case TOK_IDENT: {
				if (token_has_value(list, "throw")) {
					var line = token_get_line(list);
					copy_func_tokens(gen, list);
					token_expect_next(list);
					set_func_copy_start(gen, list);

					append_source(list_src, "return0,", &src_off);
					append_token(gen->GEN_func_tokens, KW_RETURN, src_off, 6, line);
					append_token(gen->GEN_func_tokens, TOK_NUMBER, src_off+6, 1, line);
					append_token(gen->GEN_func_tokens, ',', src_off+7, 1, line);

					token_back(list);
					gen->GEN_func_offsets_replacements{token_get_pos(list)} = -(length(gen->GEN_func_tokens)-TOK_SIZE);
					var expr_start_pos = token_get_pos(list);
					token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
					append_type_conv(gen, token_list(list), expr_start_pos, TYPE_DYNAMIC, gen->GEN_ret_type);
				
					token_expect_symbol(list, ';');
					continue;
				}
				if (token_has_value(list, "foreach")) {
					var line = token_get_line(list);
					copy_func_tokens(gen, list);
					token_expect_symbol(list, '(');
					token_expect_type(list, KW_VAR);

					token_expect_type(list, TOK_IDENT);
					var var1 = token_get_value(list), var2 = null;
					var type1 = -1, type2 = -1;
					token_expect_next(list);
					if (token_is_symbol(list, ':')) {
						parse_type(&type1, list);
						token_expect_next(list);
					}

					if (token_is_symbol(list, ',')) {
						token_expect_type(list, TOK_IDENT);
						var2 = token_get_value(list);

						token_expect_next(list);
						if (token_is_symbol(list, ':')) {
							parse_type(&type2, list);
						}
						else {
							token_back(list);
						}
					}
					else {
						token_back(list);
					}

					token_expect_type(list, TOK_IDENT);
					if (!token_has_value(list, "in")) {
						return 0, error({script_line(line), ": expected 'in'"});
					}

					var iter_var = {"__classes_tmp_", tmp_cnt++};
					var arr_var = {"__classes_tmp_", tmp_cnt++};

					tokens_parse(gen->GEN_func_tokens, list_src, {"for (var ", iter_var, "=0, ", arr_var, "="}, line);

					gen->GEN_func_offsets_replacements{token_get_pos(list)} = -(length(gen->GEN_func_tokens)-TOK_SIZE);
					token_next_nocheck(list);
					set_func_copy_start(gen, list);
					token_back(list);

					var struct_type = null;
					var expr_start_pos = token_get_pos(list);
					token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
					if (gen->GEN_ret_type != TYPE_DYNAMIC) {
						var arr_type = get_type_array_or_hash(gen->GEN_ret_type);
						if (var2) {
							if (!arr_type || arr_type[0] != EXT_TYPE_HASH) {
								return 0, error({script_line(line), ": must be a hash table"});
							}
							if (type1 == -1) type1 = arr_type->HASH_index_type;
							if (type2 == -1) type2 = arr_type->HASH_base_type;
						}
						else {
							if (is_array(gen->GEN_ret_type) && gen->GEN_ret_type[0] == EXT_TYPE_STRUCT_ARRAY) {
								struct_type = gen->GEN_ret_type->ARRAY_base_type;
								if (struct_type == TYPE_DYNAMIC) {
									return 0, error({script_line(line), ": struct array must use concrete struct type"});
								}
								if (type1 != -1) {
									return 0, error({script_line(line), ": value retyping is not allowed for structs"});
								}
								type1 = struct_type;
							}
							else {
								if (gen->GEN_ret_type == TYPE_STRING) {
									if (type1 == -1) type1 = TYPE_INTEGER;
								}
								else {
									if (!arr_type || arr_type[0] != EXT_TYPE_ARRAY) {
										return 0, error({script_line(line), ": must be an array or a string"});
									}
									if (type1 == -1) type1 = arr_type->ARRAY_base_type;
								}
							}
						}
					}
					else {
						if (type1 == -1) type1 = TYPE_DYNAMIC;
						if (type2 == -1) type2 = TYPE_DYNAMIC;
					}
					append_type_conv(gen, token_list(list), expr_start_pos, TYPE_DYNAMIC, gen->GEN_ret_type);

					token_expect_symbol(list, ')');
					copy_func_tokens(gen, list);
					token_expect_symbol(list, '{');

					if (var2) {
						tokens_parse(gen->GEN_func_tokens, list_src, {"; ", iter_var, "<length(", arr_var, "); ", iter_var, "++) { var (", var1, ", ", var2, ") = hash_entry(", arr_var, ", ", iter_var, ");"}, line);
					}
					else {
						if (struct_type) {
							tokens_parse(gen->GEN_func_tokens, list_src, {", ", var1, "; ", iter_var, "<length(", arr_var, "); ", iter_var, "+=", struct_type->CLASS_compat_name, "_SIZE) { ", var1, " = add32(", iter_var, ", ", struct_type->CLASS_compat_name, "_SIZE);"}, line);
						}
						else {
							tokens_parse(gen->GEN_func_tokens, list_src, {", ", var1, "; ", iter_var, "<length(", arr_var, "); ", iter_var, "++) { ", var1, " = ", arr_var, "[", iter_var, "];"}, line);
						}
					}

					gen->GEN_func_offsets_replacements{token_get_pos(list)} = -(length(gen->GEN_func_tokens)-TOK_SIZE);
					token_next_nocheck(list);
					set_func_copy_start(gen, list);
					token_back(list);

					var for_stack_pos = length(gen->GEN_var_stack);

					if (hash_contains(gen->GEN_vars, var1)) {
						return 0, error({script_line(line), ": duplicate variable"});
					}
					gen->GEN_vars{var1} = type1;
					gen->GEN_var_stack[] = var1;

					if (var2) {
						if (hash_contains(gen->GEN_vars, var2)) {
							return 0, error({script_line(line), ": duplicate variable"});
						}
						gen->GEN_vars{var2} = type2;
						gen->GEN_var_stack[] = var2;
					}

					token_set_pos(list, parse_block(gen, token_list(list), BT_NORMAL));

					for (var i=length(gen->GEN_var_stack)-1; i>=for_stack_pos; i--) {
						hash_remove(gen->GEN_vars, gen->GEN_var_stack[i]);
					}
					array_set_length(gen->GEN_var_stack, for_stack_pos);
					continue;
				}
				break;
			}

			case ';': {
				continue;
			}
		}

		token_back(list);
		token_set_pos(list, parse_expression(gen, token_list(list), -2, token_get_pos(list), PRIO_PRIMARY));
		token_expect_symbol(list, ';');
	}

	token_back(list);
	return 0, error({script_line(token_get_line(list)), ": unexpected EOF"});
}

macro @expression_unary_detect()
{
	switch (token_get_type(list)) {
		case '+', '-':
			token_expect_next(list);
			switch (token_get_type(list)) {
				case TOK_NUMBER, TOK_HEX_NUMBER, TOK_FLOAT_NUMBER:
					token_back(list);
					break;

				default: continue;
			}
			break;

		case '~', '!':
			token_expect_next(list);
			continue;

		case '++', '--':
			token_expect_next(list);
			continue;
	}
}

macro @expression_unary_process()
{
	switch (list_tokens[unary_off+TOK_type]) {
		case '!':
			if (type == TYPE_INTEGER || type == TYPE_FLOAT) {
				return 0, error({script_line(token_get_line(list)), ": can't use integer or float in logical negation"});
			}
			type = TYPE_BOOLEAN;
			break;
		
		case '~':
			if (type != TYPE_DYNAMIC && type != TYPE_INTEGER) {
				return 0, error({script_line(token_get_line(list)), ": bitwise negation is supported only for integers"});
			}
			type = TYPE_INTEGER;
			break;
			
		case '+':
			if (type == TYPE_FLOAT) {
				token_back(list);
				copy_func_tokens(gen, list);
				token_next_nocheck(list);
				set_func_copy_start(gen, list);
				break;
			}
			if (type != TYPE_DYNAMIC && type != TYPE_INTEGER) {
				return 0, error({script_line(token_get_line(list)), ": unary plus is supported only for integers and floats"});
			}
			type = TYPE_INTEGER;
			break;

		case '-':
			if (type == TYPE_FLOAT) {
				token_next_nocheck(list);
				copy_func_tokens(gen, list);
				token_back(list);
				wrap_float_unary_op(gen, token_list(list), unary_off - TOK_SIZE);
				break;
			}
			if (type != TYPE_DYNAMIC && type != TYPE_INTEGER) {
				return 0, error({script_line(token_get_line(list)), ": unary minus is supported only for integers and floats"});
			}
			type = TYPE_INTEGER;
			break;
		
		case '++', '--':
			if (is_array(type) && type[0] == EXT_TYPE_STRUCT) {
				token_next_nocheck(list);
				copy_func_tokens(gen, list);
				token_back(list);
				var line = token_get_line(list);
				insert_func_tokens(gen, list, off, 0, &func_tokens, &func_pos);
				append_source(list_src, "(", &src_off);
				insert_token(func_tokens, func_pos, '(', src_off+0, 1, line);
				tokens_parse(gen->GEN_func_tokens, list_src, {list_tokens[unary_off+TOK_type] == '++'? "+=" : "-=", type->CLASS_compat_name, "_SIZE)"}, line);
				break;
			}
			if (type != TYPE_DYNAMIC && type != TYPE_INTEGER) {
				return 0, error({script_line(token_get_line(list)), ": pre increment/decrement is supported only for integers"});
			}
			type = TYPE_INTEGER;
			break;
	}
}

function @obtain_generic_types(dest_type, src_type, generic_types)
{
	if (dest_type == TYPE_KEY) {
		if (generic_types[0] == -1) {
			generic_types[0] = src_type;
		}
		return;
	}
	if (dest_type == TYPE_VALUE) {
		if (generic_types[1] == -1) {
			generic_types[1] = src_type;
		}
		return;
	}
	
	if (is_array(dest_type) && dest_type[0] == EXT_TYPE_ARRAY) {
		if (src_type == TYPE_STRING) {
			obtain_generic_types(dest_type->ARRAY_base_type, TYPE_INTEGER, generic_types);
		}
		else if (is_array(src_type) && src_type[0] == EXT_TYPE_ARRAY) {
			obtain_generic_types(dest_type->ARRAY_base_type, src_type->ARRAY_base_type, generic_types);
		}
		return;
	}

	if (is_array(dest_type) && dest_type[0] == EXT_TYPE_HASH && is_array(src_type) && src_type[0] == EXT_TYPE_HASH) {
		obtain_generic_types(dest_type->HASH_base_type, src_type->HASH_base_type, generic_types);
		obtain_generic_types(dest_type->HASH_index_type, src_type->HASH_index_type, generic_types);
		return;
	}
}

function @apply_generic_types(type, generic_types, line)
{
	if (type == TYPE_KEY) {
		if (generic_types[0] == -1) {
			return 0, error({script_line(line), ": generic key type not defined"});
		}
		return generic_types[0];
	}
	if (type == TYPE_VALUE) {
		if (generic_types[1] == -1) {
			return 0, error({script_line(line), ": generic value type not defined"});
		}
		return generic_types[1];
	}
	if (is_array(type) && type[0] == EXT_TYPE_ARRAY) {
		return create_array_type(
			apply_generic_types(type->ARRAY_base_type, generic_types, line)
		);
	}
	if (is_array(type) && type[0] == EXT_TYPE_HASH) {
		return create_hash_type(
			apply_generic_types(type->HASH_base_type, generic_types, line),
			apply_generic_types(type->HASH_index_type, generic_types, line)
		);
	}
	return type;
}

macro @expression_primary()
{
	switch (token_get_type(list)) {
		case '(': {
			token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
			type = gen->GEN_ret_type;
			token_expect_symbol(list, ')');
			break;
		}

		case '[': {
			token_expect_next(list);
			if (token_is_symbol(list, ']')) {
				type = create_array_type(TYPE_DYNAMIC);
				break;
			}
			else {
				token_back(list);
			}
			var common_type = -1;
			for (;;) {
				token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
				if (common_type == -1) {
					common_type = gen->GEN_ret_type;
				}
				else if (common_type != gen->GEN_ret_type) {
					common_type = TYPE_DYNAMIC;
				}
				token_expect_next(list);
				if (token_is_symbol(list, ',')) continue;
				break;
			}
			token_back(list);
			token_expect_symbol(list, ']');
			type = create_array_type(common_type);
			break;
		}

		case '{': {
			token_expect_next(list);
			if (token_is_symbol(list, '}')) {
				type = create_hash_type(TYPE_DYNAMIC, TYPE_DYNAMIC);
				break;
			}
			if (token_is_symbol(list, '=')) {
				token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
				type = gen->GEN_ret_type;
				token_expect_symbol(list, '}');
				break;
			}
			token_back(list);
			var pos = token_get_pos(list);
			var ext_type = -1, level = 0, first = true;
			while (token_next(list)) {
				switch (token_get_type(list)) {
					case '(':
					case '{':
					case '[':
						level++;
						first = false;
						continue;

					case ')':
					case '}':
					case ']':
						if (--level < 0) break;
						if (level == 0 && token_get_type(list) == '}') {
							if (token_next(list) && token_is_symbol(list, '=')) {
								ext_type = ET_BLOCK;
								break;
							}
							else {
								token_back(list);
							}
						}
						first = false;
						continue;

					case '+':
					case '-':
						if (first) {
							first = false;
							continue;
						}
						// fallthrough

					case '*':
					case '/':
					case '<':
					case '>':
						if (level == 0 && ext_type == -1) {
							ext_type = ET_FLOAT;
						}
						first = false;
						continue;

					case '?':
						if (level == 0 && ext_type == -1) {
							ext_type = ET_STRING;
						}
						first = false;
						continue;

					case ':':
						if (level == 0 && ext_type == -1) {
							ext_type = ET_HASH;
						}
						first = false;
						continue;

					case ',':
						if (level == 0 && (ext_type == -1 || ext_type == ET_FLOAT)) {
							ext_type = ET_STRING;
						}
						first = false;
						continue;

					case ';':
						if (level == 0) {
							if (token_next(list) && token_is_symbol(list, '=')) {
								ext_type = ET_BLOCK;
								break;
							}
							else {
								token_back(list);
							}
						}
						first = false;
						continue;
	
					case '<=':
					case '>=':
					case '==':
					case '!=':
						if (level == 0 && ext_type == -1) {
							ext_type = ET_FLOAT;
						}
						first = false;
						continue;

					default:
						first = false;
						continue;
				}
				break;
			}
			if (ext_type == -1) {
				ext_type = ET_STRING;
			}
			token_set_pos(list, pos);
			if (ext_type == ET_BLOCK) {
				token_set_pos(list, parse_block(gen, token_list(list), BT_EXPR));
				type = gen->GEN_ret_type;
				break;
			}
			if (ext_type == ET_FLOAT) {
				var float_op = -1;
				for (;;) {
					token_set_pos(list, parse_primary_expression(gen, token_list(list)));
					token_expect_next(list);
					var fop = -1;
					var tok_type = token_get_type(list);
					if (tok_type >= ' ') {
						if (tok_type == '}' && float_op != -1) break;
						switch (tok_type) {
							case '+', '-': fop = FO_ADD_SUB; break;
							case '*', '/': fop = FO_MUL_DIV; break;
						}
					}
					if (fop == -1 || (float_op != -1 && fop != float_op)) {
						return 0, error({script_line(token_get_line(list)), ": expected float operator"});
					}
					float_op = fop;
				}
				type = TYPE_FLOAT;
				break;
			}
			if (ext_type == ET_HASH) {
				var common_base_type = -1;
				var common_index_type = -1;
				for (;;) {
					token_expect_next(list);
					if (token_is_symbol(list, '}')) break;
					token_back(list);
					token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
					if (common_index_type == -1) {
						common_index_type = gen->GEN_ret_type;
					}
					else if (common_index_type != gen->GEN_ret_type) {
						common_index_type = TYPE_DYNAMIC;
					}
					token_expect_symbol(list, ':');
					token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
					if (common_base_type == -1) {
						common_base_type = gen->GEN_ret_type;
					}
					else if (common_base_type != gen->GEN_ret_type) {
						common_base_type = TYPE_DYNAMIC;
					}
					token_expect_next(list);
					if (token_is_symbol(list, ',')) continue;
					token_back(list);
					token_expect_symbol(list, '}');
					break;
				}
				type = create_hash_type(common_base_type, common_index_type);
				break;
			}
			if (ext_type == ET_STRING) {
				for (;;) {
					token_expect_next(list);
					if (token_is_symbol(list, '}')) break;
					token_back(list);
					token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
					token_expect_next(list);
					if (token_is_symbol(list, ',')) continue;
					token_back(list);
					token_expect_symbol(list, '}');
					break;
				}
				type = TYPE_STRING;
				break;
			}
			return 0, error({script_line(token_get_line(list)), ": internal error: invalid extended operator"});
		}

		case '@': {
			token_expect_type(list, TOK_IDENT);
			var func_name = token_get_value(list);
			token_expect_symbol(list, '(');
			var params_off = token_get_pos(list);
			token_expect_next(list);
			var num_params = 0;
			if (!token_is_symbol(list, ')')) {
				token_back(list);
				for (;;) {
					num_params++;
					token_expect_expression(list);
					token_expect_next(list);
					if (token_is_symbol(list, ',')) continue;
					token_back(list);
					break;
				}
				token_expect_symbol(list, ')');
			}

			var name = {func_name, "#", num_params};
			var func = hash_get(builtin_functions, name, null);
			if (func) {
				token_set_pos(list, params_off);
				for (var i=0; i<num_params; i++) {
					if (i > 0) {
						token_expect_symbol(list, ',');
					}
					var (param_name, param_type) = hash_entry(func->FUNC_params, (func->FUNC_flags & FUNC_FLAG_STATIC)? i : i+1);
					var param_start_pos = token_get_pos(list);
					token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
					append_type_conv(gen, token_list(list), param_start_pos, param_type, gen->GEN_ret_type);
				}
				token_expect_symbol(list, ')');
				type = func->FUNC_return_type;
			}
			else {
				token_set_pos(list, params_off);
				for (var i=0; i<num_params; i++) {
					if (i > 0) {
						token_expect_symbol(list, ',');
					}
					var param_start_pos = token_get_pos(list);
					token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
					append_type_conv(gen, token_list(list), param_start_pos, TYPE_DYNAMIC, gen->GEN_ret_type);
				}
				token_expect_symbol(list, ')');
				type = TYPE_DYNAMIC;
			}
			break;
		}

		case '+', '-':
			token_expect_next(list);
			switch (token_get_type(list)) {
				case TOK_NUMBER, TOK_HEX_NUMBER:
					type = TYPE_INTEGER;
					break;

				case TOK_FLOAT_NUMBER:
					type = TYPE_FLOAT;
					break;
			}
			break;

		case TOK_NUMBER, TOK_HEX_NUMBER, TOK_CHAR:
			type = TYPE_INTEGER;
			break;

		case TOK_FLOAT_NUMBER:
			type = TYPE_FLOAT;
			break;

		case TOK_STRING:
			type = TYPE_STRING;
			break;

		case TOK_FUNC_REF:
			type = TYPE_DYNAMIC;
			break;

		case TOK_IDENT: {
			var var_name = token_get_value(list);
			if (var_name == "new") {
				var line = token_get_line(list);
				copy_func_tokens(gen, list);
				token_expect_type(list, TOK_IDENT);
				var class_name = token_get_value(list);
				var class = find_class(gen, class_name);
				if (!class) {
					return 0, error({script_line(token_get_line(list)), ": unknown class ", class_name});
				}
				if (class->CLASS_ext_type == EXT_TYPE_STRUCT) {
					return 0, error({script_line(token_get_line(list)), ": can't use new on structs"});
				}
				if (class !== hash_get(gen->GEN_classes, class->CLASS_name, null)) {
					return 0, error({script_line(token_get_line(list)), ": can't use new on class ", class_name, " from other script"});
				}
				token_expect_next(list);
				var extend = false;
				if (token_is_symbol(list, ':')) {
					extend = true;
					if (!class->CLASS_parent) {
						return 0, error({script_line(token_get_line(list)), ": class ", class_name, " has no parent"});
					}
				}
				else {
					token_back(list);
				}
				token_next_nocheck(list);
				set_func_copy_start(gen, list);
				token_back(list);

				if (extend) {
					if (class->CLASS_virtual) {
						var name = {"vfunc__", class->CLASS_method_prefix, "_object_extend"};
						append_source(list_src, name, &src_off);
						append_source(list_src, "()", &src_off2);
						append_token(gen->GEN_func_tokens, TOK_IDENT, src_off, length(name), line);

						append_token(gen->GEN_func_tokens, '(', src_off2, 1, line);

						var expr_start_pos = token_get_pos(list);
						token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
						append_type_conv(gen, token_list(list), expr_start_pos, class->CLASS_parent, gen->GEN_ret_type);

						token_next_nocheck(list);
						copy_func_tokens(gen, list);
						token_back(list);

						append_token(gen->GEN_func_tokens, ')', src_off2+1, 1, line);
					}
					else {
						append_source(list_src, "object_extend(,)", &src_off);
						append_token(gen->GEN_func_tokens, TOK_IDENT, src_off, 13, line);
						append_token(gen->GEN_func_tokens, '(', src_off+13, 1, line);

						var expr_start_pos = token_get_pos(list);
						token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
						append_type_conv(gen, token_list(list), expr_start_pos, class->CLASS_parent, gen->GEN_ret_type);

						token_next_nocheck(list);
						copy_func_tokens(gen, list);
						token_back(list);

						append_token(gen->GEN_func_tokens, ',', src_off+14, 1, line);

						var size_const = {class->CLASS_compat_name, "_SIZE"};
						append_source(list_src, size_const, &src_off2);
						append_token(gen->GEN_func_tokens, TOK_IDENT, src_off2, length(size_const), line);

						append_token(gen->GEN_func_tokens, ')', src_off+15, 1, line);
					}
				}
				else {
					if (class->CLASS_virtual) {
						var name = {"vfunc__", class->CLASS_method_prefix, "_object_create"};
						append_source(list_src, name, &src_off);
						append_token(gen->GEN_func_tokens, TOK_IDENT, src_off, length(name), line);

						append_source(list_src, "()", &src_off2);
						append_token(gen->GEN_func_tokens, '(', src_off2, 1, line);
						append_token(gen->GEN_func_tokens, ')', src_off2+1, 1, line);
					}
					else {
						append_source(list_src, "object_create()", &src_off);
						append_token(gen->GEN_func_tokens, TOK_IDENT, src_off, 13, line);
						append_token(gen->GEN_func_tokens, '(', src_off+13, 1, line);

						var size_const = {class->CLASS_compat_name, "_SIZE"};
						append_source(list_src, size_const, &src_off2);
						append_token(gen->GEN_func_tokens, TOK_IDENT, src_off2, length(size_const), line);

						append_token(gen->GEN_func_tokens, ')', src_off+14, 1, line);
					}
				}
				
				type = class;
				break;
			}
			else if (var_name == "super") {
				var line = token_get_line(list);
				var class = gen->GEN_cur_class;
				if (!class) {
					return 0, error({script_line(token_get_line(list)), ": must be used in class"});
				}
				if (gen->GEN_cur_func->FUNC_flags & FUNC_FLAG_STATIC) {
					return 0, error({script_line(token_get_line(list)), ": must be used in instance method"});
				}
				token_expect_symbol(list, '.');
				token_expect_type(list, TOK_IDENT);
				var func_name = token_get_value(list);

				token_back(list);
				token_back(list);
				copy_func_tokens(gen, list);
				token_next_nocheck(list);
				token_next_nocheck(list);

				token_expect_symbol(list, '(');
				set_func_copy_start(gen, list);
				var params_off = token_get_pos(list);
				token_expect_next(list);

				var num_params = 0;
				if (token_is_symbol(list, ')')) {
					token_back(list);
				}
				else {
					token_back(list);
					for (;;) {
						num_params++;
						token_expect_expression(list);
						token_expect_next(list);
						if (token_is_symbol(list, ',')) continue;
						token_back(list);
						break;
					}
				}
				token_expect_symbol(list, ')');
				
				tokens_parse(gen->GEN_func_tokens, list_src, {"this->", gen->GEN_cur_class->CLASS_compat_name, "__super__", func_name, "__", num_params+1}, line);

				var name = {func_name, "#", num_params+1};
				var func = null;
				for (;;) {
					class = class->CLASS_parent;
					if (!class) {
						return 0, error({script_line(token_get_line(list)), ": virtual function ", func_name, " not found in super classes"});
					}

					func = hash_get(class->CLASS_functions, name, null);
					if (func && (func->FUNC_flags & (FUNC_FLAG_VIRTUAL | FUNC_FLAG_OVERRIDE)) == FUNC_FLAG_VIRTUAL) {
						break;
					}
				}

				token_set_pos(list, params_off);
				for (var i=0; i<num_params; i++) {
					if (i > 0) {
						token_expect_symbol(list, ',');
					}
					var (param_name, param_type) = hash_entry(func->FUNC_params, i+1);
					var param_start_pos = token_get_pos(list);
					token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
					append_type_conv(gen, token_list(list), param_start_pos, param_type, gen->GEN_ret_type);
				}
				token_expect_symbol(list, ')');

				copy_func_tokens(gen, list);
				if (num_params > 0) {
					append_source(list_src, "this,", &src_off);
					insert_func_tokens(gen, list, params_off, 2, &func_tokens, &func_pos);
					insert_token(func_tokens, func_pos, TOK_IDENT, src_off, 4, line);
					insert_token(func_tokens, func_pos, ',', src_off+4, 1, line);
				}
				else {
					append_source(list_src, "this", &src_off);
					insert_func_tokens(gen, list, params_off, 1, &func_tokens, &func_pos);
					insert_token(func_tokens, func_pos, TOK_IDENT, src_off, 4, line);
				}

				type = func->FUNC_return_type;
				break;
			}
			if (token_next(list)) {
				if (token_is_symbol(list, ':')) {
					if (token_next(list)) {
						if (token_is_symbol(list, ':')) {
							token_expect_next(list);
							if (token_get_type(list) == TOK_FUNC_REF) {
								token_back(list);
								token_back(list);
								token_back(list);
								var cls_name = token_get_value(list);
								var class = find_class(gen, cls_name);
								if (!class) {
									return 0, error({script_line(token_get_line(list)), ": unknown class ", cls_name});
								}
								copy_func_tokens(gen, list);
								token_next_nocheck(list);
								token_next_nocheck(list);
								token_next_nocheck(list);
								set_func_copy_start(gen, list);
								var func_name = token_get_value(list);
								var func = hash_get(class->CLASS_functions, func_name, null);
								if (!func || ((func->FUNC_flags & FUNC_FLAG_PRIVATE) && class !== hash_get(gen->GEN_classes, class->CLASS_name, null))) {
									return 0, error({script_line(token_get_line(list)), ": unknown method ", func_name, " in ", cls_name});
								}
								var func_ref = {class->CLASS_method_prefix, func_name};
								append_source(list_src, func_ref, &src_off);
								list_tokens[list_off+TOK_off] = src_off;
								list_tokens[list_off+TOK_len] = length(func_ref);
								type = TYPE_DYNAMIC;
								break;
							}
							else if (token_get_type(list) != TOK_IDENT) {
								return 0, error({script_line(token_get_line(list)), ": expected identifier or function reference"});
							}
							var line = token_get_line(list);
							var func_name = token_get_value(list);
							//log({"obj=", var_name, " func=", func_name});
							var class = find_class(gen, var_name);
							if (!class) {
								var kind;
								if (var_name == "Array") {
									kind = "array";
								}
								else if (var_name == "String") {
									kind = "string";
								}
								else if (var_name == "Hash") {
									kind = "hash";
								}
								if (kind) {
									token_back(list);
									token_back(list);
									token_back(list);
									copy_func_tokens(gen, list);
									token_next_nocheck(list);
									token_next_nocheck(list);
									token_next_nocheck(list);

									token_expect_symbol(list, '(');
									set_func_copy_start(gen, list);
									var params_off = token_get_pos(list);
									token_expect_next(list);

									var num_params = 0;
									if (token_is_symbol(list, ')')) {
										token_back(list);
									}
									else {
										token_back(list);
										for (;;) {
											num_params++;
											token_expect_expression(list);
											token_expect_next(list);
											if (token_is_symbol(list, ',')) continue;
											token_back(list);
											break;
										}
									}
									token_expect_symbol(list, ')');

									var name = {kind, "_", func_name, "#", num_params};
									var func = null;
									if (gen->GEN_static_functions) {
										func = hash_get(gen->GEN_static_functions, name, null);
									}
									if (!func) {
										if (gen->GEN_imported_static_functions) {
											func = hash_get(gen->GEN_imported_static_functions, name, null);
										}
										if (!func) {
											func = hash_get(builtin_static_functions, name, null);
										}
									}
									if (!func) {
										return 0, error({script_line(line), ": static function ", name, " not found for ", kind, " type"});
									}

									var full_name = func->FUNC_alt_name? func->FUNC_alt_name : func->FUNC_name;
									append_source(list_src, full_name, &src_off);
									append_token(gen->GEN_func_tokens, TOK_IDENT, src_off, length(full_name), line);

									var generic_types = [-1, -1];

									token_set_pos(list, params_off);
									for (var i=0; i<num_params; i++) {
										if (i > 0) {
											token_expect_symbol(list, ',');
										}
										var (param_name, param_type) = hash_entry(func->FUNC_params, i);
										var param_start_pos = token_get_pos(list);
										token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
										obtain_generic_types(param_type, gen->GEN_ret_type, generic_types);
										param_type = apply_generic_types(param_type, generic_types, token_get_line(list));
										append_type_conv(gen, token_list(list), param_start_pos, param_type, gen->GEN_ret_type);
									}
									token_expect_symbol(list, ')');

									type = apply_generic_types(func->FUNC_return_type, generic_types, line);
									break;
								}
								return 0, error({script_line(token_get_line(list)), ": unknown class ", var_name});
							}

							token_back(list);
							token_back(list);
							token_back(list);
							copy_func_tokens(gen, list);
							token_next_nocheck(list);
							token_next_nocheck(list);
							token_next_nocheck(list);

							token_expect_next(list);
							if (!token_is_symbol(list, '(')) {
								set_func_copy_start(gen, list);
								token_back(list);
								if (func_name == "SIZE") {
									tokens_parse(gen->GEN_func_tokens, list_src, {class->CLASS_compat_name, "_SIZE"}, line);
									type = TYPE_INTEGER;
								}
								else {
									var cls = class;
									var found = false;
									while (cls) {
										var field = hash_get(cls->CLASS_fields, func_name, null);
										if (field && (!field->FIELD_private || cls === hash_get(gen->GEN_classes, cls->CLASS_name, null))) {
											tokens_parse(gen->GEN_func_tokens, list_src, {cls->CLASS_compat_name, "_", func_name}, line);
											type = TYPE_INTEGER;
											found = true;
											break;
										}
										cls = cls->CLASS_parent;
									}
									if (!found) {
										return 0, error({script_line(token_get_line(list)), ": unknown field ", func_name, " in ", get_class_name_with_kind(class)});
									}
								}
								break;
							}

							set_func_copy_start(gen, list);
							var params_off = token_get_pos(list);
							token_expect_next(list);
							var num_params = 0;
							if (token_is_symbol(list, ')')) {
								token_back(list);
							}
							else {
								token_back(list);
								for (;;) {
									num_params++;
									token_expect_expression(list);
									token_expect_next(list);
									if (token_is_symbol(list, ',')) continue;
									token_back(list);
									break;
								}
							}
							token_expect_symbol(list, ')');

							var name = {func_name, "#", num_params};
							var func = hash_get(class->CLASS_functions, name, null);
							if (func && (!(func->FUNC_flags & FUNC_FLAG_STATIC) || ((func->FUNC_flags & FUNC_FLAG_PRIVATE) && class !== hash_get(gen->GEN_classes, class->CLASS_name, null)))) {
								func = null;
							}
							if (!func) {
								return 0, error({script_line(line), ": static function ", name, " not found in ", get_class_name_with_kind(class)});
							}

							var full_name = {class->CLASS_method_prefix, func->FUNC_name};
							append_source(list_src, full_name, &src_off);
							append_token(gen->GEN_func_tokens, TOK_IDENT, src_off, length(full_name), line);

							token_set_pos(list, params_off);
							for (var i=0; i<num_params; i++) {
								if (i > 0) {
									token_expect_symbol(list, ',');
								}
								var (param_name, param_type) = hash_entry(func->FUNC_params, i);
								var param_start_pos = token_get_pos(list);
								token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
								append_type_conv(gen, token_list(list), param_start_pos, param_type, gen->GEN_ret_type);
							}
							token_expect_symbol(list, ')');

							type = func->FUNC_return_type;
							break;
						}
						else if (token_get_type(list) == TOK_IDENT || token_get_type(list) == TOK_FUNC_REF) {
							token_back(list);
							token_back(list);
							var alias = token_get_value(list);
							token_next_nocheck(list);
							token_next_nocheck(list);
							var ia = gen->GEN_import_aliases? hash_get(gen->GEN_import_aliases, alias, null) : null;
							if (ia) {
								var name = token_get_value(list);
								var const_type = hash_get(ia->IMPORT_ALIAS_consts, name, -1);
								if (const_type != -1) {
									type = const_type;
									break;
								}
								if (hash_contains(ia->IMPORT_ALIAS_locals, name)) {
									type = TYPE_DYNAMIC;
									break;
								}
								if (hash_contains(ia->IMPORT_ALIAS_funcs, name)) {
									if (token_get_type(list) == TOK_FUNC_REF) {
										type = TYPE_DYNAMIC;
										break;
									}
									token_expect_symbol(list, '(');
									token_expect_next(list);
									if (!token_is_symbol(list, ')')) {
										token_back(list);
										for (;;) {
											token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
											token_expect_next(list);
											if (token_is_symbol(list, ',')) continue;
											token_back(list);
											break;
										}
										token_expect_symbol(list, ')');
									}
									type = TYPE_DYNAMIC;
									break;
								}
								return 0, error({script_line(token_get_line(list)), ": constant, local variable or function not found in script with import alias '", alias, "'"});
							}
							else {
								token_back(list);
								token_back(list);
							}
						}
						else {
							token_back(list);
							token_back(list);
						}
					}
					else {
						token_back(list);
						token_back(list);
					}
				}
				else {
					token_back(list);
				}
			}
			else {
				token_back(list);
			}
			type = hash_get(gen->GEN_consts, var_name, -1);
			if (type == -1) {
				switch (length(var_name)) {
					case 4:
						if (var_name == "null") { type = TYPE_DYNAMIC; break; }
						if (var_name == "true") { type = TYPE_BOOLEAN; break; }
						break;

					case 5:
						if (var_name == "false") { type = TYPE_BOOLEAN; break; }
						break;
				}
			}
			if (type == -1) {
				type = hash_get(gen->GEN_vars, var_name, -1);
			}
			if (type == -1) {
				var class = gen->GEN_cur_class;
				while (class) {
					var field = hash_get(class->CLASS_fields, var_name, null);
					if (field && (!field->FIELD_private || class === hash_get(gen->GEN_classes, class->CLASS_name, null))) {
						if ((gen->GEN_cur_func->FUNC_flags & (FUNC_FLAG_STATIC | FUNC_FLAG_CONSTRUCTOR)) == FUNC_FLAG_STATIC) {
							return 0, error({script_line(token_get_line(list)), ": can't reference instance fields"});
						}
						copy_func_tokens(gen, list);
						var line = token_get_line(list);
						append_source(list_src, {"this->", field->FIELD_compat_name}, &src_off);
						append_token(gen->GEN_func_tokens, TOK_IDENT, src_off, 4, line);
						append_token(gen->GEN_func_tokens, '->', src_off+4, 2, line);
						append_token(gen->GEN_func_tokens, TOK_IDENT, src_off+6, length(field->FIELD_compat_name), line);
						gen->GEN_func_offsets_replacements{token_get_pos(list)} = -(length(gen->GEN_func_tokens)+TOK_SIZE);
						token_next(list);
						set_func_copy_start(gen, list);
						token_back(list);
						type = field->FIELD_type;
						break;
					}
					class = class->CLASS_parent;
				}
			}
			if (type == -1 && gen->GEN_locals) {
				var local = hash_get(gen->GEN_locals, var_name, null);
				if (local) {
					type = local->LOCAL_type;
				}
			}
			if (type == -1 && gen->GEN_imported_locals) {
				var local = hash_get(gen->GEN_imported_locals, var_name, null);
				if (local) {
					type = local->LOCAL_type;
				}
			}
			if (type == -1) {
				if (token_next(list)) {
					if (token_is_symbol(list, '(')) {
						token_back(list);
						var line = token_get_line(list);
						var func_name = token_get_value(list);
						token_next_nocheck(list);
						var params_off = token_get_pos(list);
						token_expect_next(list);

						var num_params = 0;
						if (token_is_symbol(list, ')')) {
							token_back(list);
						}
						else {
							token_back(list);
							for (;;) {
								num_params++;
								token_expect_expression(list);
								token_expect_next(list);
								if (token_is_symbol(list, ',')) continue;
								token_back(list);
								break;
							}
						}
						token_expect_symbol(list, ')');

						var name = {func_name, "#", num_params};
						if (gen->GEN_cur_class) {
							var class = gen->GEN_cur_class;
							var func, orig_class = class, struct_type;
							var instance_name = {func_name, "#", num_params+1};

							while (class) {
								func = hash_get(class->CLASS_functions, instance_name, null);
								if (func) {
									if (!(func->FUNC_flags & FUNC_FLAG_STATIC) && !(func->FUNC_flags & FUNC_FLAG_OVERRIDE) && (!(func->FUNC_flags & FUNC_FLAG_PRIVATE) || class === hash_get(gen->GEN_classes, class->CLASS_name, null))) {
										if ((gen->GEN_cur_func->FUNC_flags & (FUNC_FLAG_STATIC | FUNC_FLAG_CONSTRUCTOR)) == FUNC_FLAG_STATIC) {
											return 0, error({script_line(token_get_line(list)), ": can't reference instance methods"});
										}
										break;
									}
									func = null;
								}
								class = class->CLASS_parent;
							}
							if (!func) {
								class = orig_class;
								while (class) {
									func = hash_get(class->CLASS_functions, name, null);
									if (func) {
										if ((func->FUNC_flags & FUNC_FLAG_STATIC) && (!(func->FUNC_flags & FUNC_FLAG_PRIVATE) || class === hash_get(gen->GEN_classes, class->CLASS_name, null))) {
											break;
										}
										func = null;
									}
									class = class->CLASS_parent;
								}
								if (!func) {
									func = find_function(gen, name);
									if (!func && num_params == 1) {
										struct_type = find_class(gen, func_name);
										if (!struct_type || struct_type->CLASS_ext_type != EXT_TYPE_STRUCT) {
											struct_type = null;
										}
									}
								}
							}
							/*
							if (!func) {
								return 0, error({script_line(line), ": function ", name, " not found in ", get_class_name_with_kind(orig_class)});
							}
							*/

							token_set_pos(list, params_off);
							if (func) {
								for (var i=0; i<num_params; i++) {
									if (i > 0) {
										token_expect_symbol(list, ',');
									}
									var (param_name, param_type) = hash_entry(func->FUNC_params, (func->FUNC_flags & FUNC_FLAG_STATIC)? i : i+1);
									var param_start_pos = token_get_pos(list);
									token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
									append_type_conv(gen, token_list(list), param_start_pos, param_type, gen->GEN_ret_type);
								}
							}
							else if (struct_type) {
								token_back(list);
								copy_func_tokens(gen, list);
								token_next_nocheck(list);
								set_func_copy_start(gen, list);

								token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
								append_type_conv(gen, token_list(list), params_off, TYPE_INTEGER, gen->GEN_ret_type);
							}
							else {
								var ctx = gen->GEN_custom_ctx;
								var func_call_list = null, func_call_idx, func_types = null, call_start_pos;
								if (ctx) {
									var func_list = hash_get(ctx->CTX_function_calls, func_name, ctx->CTX_function_calls_any);
									if (func_list) {
										for (var i=0; i<length(func_list); i+=FUNC_CALL_SIZE) {
											func_types = func_list[i+FUNC_CALL_get_types_func](func_list[i+FUNC_CALL_data], func_name, num_params, token_get_line(list));
											if (func_types) {
												if (length(func_types) != num_params+1) {
													return 0, error({"improper number of function types returned by other token processor at ", script_line(token_get_line(list))});
												}
												token_next_nocheck(list);
												copy_func_tokens(gen, list);
												token_back(list);
												call_start_pos = length(gen->GEN_func_tokens);
												func_call_list = func_list;
												func_call_idx = i;
												break;
											}
										}
									}
								}
								for (var i=0; i<num_params; i++) {
									if (i > 0) {
										token_expect_symbol(list, ',');
									}
									var param_start_pos = token_get_pos(list);
									token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
									if (func_types) {
										if (func_types[i+1] == TYPE_DYNAMIC) {
											func_types[i+1] = gen->GEN_ret_type;
										}
										else {
											append_type_conv(gen, token_list(list), param_start_pos, func_types[i+1], gen->GEN_ret_type);
										}
									}
								}
								if (func_types) {
									token_expect_symbol(list, ')');
									token_next_nocheck(list);
									copy_func_tokens(gen, list);
									token_back(list);
									token_back(list);
									var end_pos = func_call_list[func_call_idx+FUNC_CALL_adjust_call_func](func_call_list[func_call_idx+FUNC_CALL_data], func_name, func_types, gen->GEN_func_tokens, list_src, call_start_pos - TOK_SIZE*2, length(gen->GEN_func_tokens));
									if (end_pos != length(gen->GEN_func_tokens)) {
										return 0, error({"invalid end position returned by other token processor at ", script_line(token_get_line(list))});
									}
									type = func_types[0];
								}
							}
							token_expect_symbol(list, ')');

							token_next_nocheck(list);
							copy_func_tokens(gen, list);
							token_back(list);

							if (func) {
								if (class) {
									var full_name = {class->CLASS_method_prefix, func->FUNC_name};
									append_source(list_src, full_name, &src_off);
									var search_off = list_tokens[params_off-TOK_SIZE+TOK_off];
									var func_tokens = gen->GEN_func_tokens;
									for (var idx=length(func_tokens)-TOK_SIZE; ; idx-=TOK_SIZE) {
										if (func_tokens[idx+TOK_off] == search_off) {
											func_tokens[idx+TOK_type] = TOK_IDENT;
											func_tokens[idx+TOK_off] = src_off;
											func_tokens[idx+TOK_len] = length(full_name);
											break;
										}
									}
								}

								if (!(func->FUNC_flags & FUNC_FLAG_STATIC)) {
									if (num_params > 0) {
										append_source(list_src, "this,", &src2_off);
										insert_func_tokens(gen, list, params_off, 2, &func_tokens2, &func_pos);
										insert_token(func_tokens2, func_pos, TOK_IDENT, src2_off, 4, line);
										insert_token(func_tokens2, func_pos, ',', src2_off+4, 1, line);
									}
									else {
										append_source(list_src, "this", &src2_off);
										insert_func_tokens(gen, list, params_off, 1, &func_tokens2, &func_pos);
										insert_token(func_tokens2, func_pos, TOK_IDENT, src2_off, 4, line);
									}
								}

								type = func->FUNC_return_type;
							}
							else if (struct_type) {
								append_source(list_src, "add32(", &src_off);
								insert_func_tokens(gen, list, params_off-2*TOK_SIZE, 2, &func_tokens2, &func_pos);
								insert_token(func_tokens2, func_pos, TOK_IDENT, src_off, 5, line);
								insert_token(func_tokens2, func_pos, '(', src_off+5, 1, line);
								tokens_parse(gen->GEN_func_tokens, list_src, {"*", struct_type->CLASS_compat_name, "_SIZE, ", struct_type->CLASS_compat_name, "_SIZE)"}, token_get_line(list));
								type = struct_type;
							}
						}
						else {
							var func = find_function(gen, name), struct_type;
							if (!func && num_params == 1) {
								struct_type = find_class(gen, func_name);
								if (!struct_type || struct_type->CLASS_ext_type != EXT_TYPE_STRUCT) {
									struct_type = null;
								}
							}
							token_set_pos(list, params_off);
							if (func) {
								for (var i=0; i<num_params; i++) {
									if (i > 0) {
										token_expect_symbol(list, ',');
									}
									var (param_name, param_type) = hash_entry(func->FUNC_params, i);
									var param_start_pos = token_get_pos(list);
									token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
									append_type_conv(gen, token_list(list), param_start_pos, param_type, gen->GEN_ret_type);
								}
								token_expect_symbol(list, ')');
								type = func->FUNC_return_type;
							}
							else if (struct_type) {
								token_back(list);
								copy_func_tokens(gen, list);
								token_next_nocheck(list);
								set_func_copy_start(gen, list);

								token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
								append_type_conv(gen, token_list(list), params_off, TYPE_INTEGER, gen->GEN_ret_type);
								token_expect_symbol(list, ')');

								token_next_nocheck(list);
								copy_func_tokens(gen, list);
								token_back(list);

								append_source(list_src, "add32(", &src_off);
								insert_func_tokens(gen, list, params_off-2*TOK_SIZE, 2, &func_tokens2, &func_pos);
								insert_token(func_tokens2, func_pos, TOK_IDENT, src_off, 5, line);
								insert_token(func_tokens2, func_pos, '(', src_off+5, 1, line);
								tokens_parse(gen->GEN_func_tokens, list_src, {"*", struct_type->CLASS_compat_name, "_SIZE, ", struct_type->CLASS_compat_name, "_SIZE)"}, token_get_line(list));
								type = struct_type;
							}
							else {
								var ctx = gen->GEN_custom_ctx;
								var func_call_list = null, func_call_idx, func_types = null, call_start_pos;
								if (ctx) {
									var func_list = hash_get(ctx->CTX_function_calls, func_name, ctx->CTX_function_calls_any);
									if (func_list) {
										for (var i=0; i<length(func_list); i+=FUNC_CALL_SIZE) {
											func_types = func_list[i+FUNC_CALL_get_types_func](func_list[i+FUNC_CALL_data], func_name, num_params, token_get_line(list));
											if (func_types) {
												if (length(func_types) != num_params+1) {
													return 0, error({"improper number of function types returned by other token processor at ", script_line(token_get_line(list))});
												}
												token_next_nocheck(list);
												copy_func_tokens(gen, list);
												token_back(list);
												call_start_pos = length(gen->GEN_func_tokens);
												func_call_list = func_list;
												func_call_idx = i;
												break;
											}
										}
									}
								}
								for (var i=0; i<num_params; i++) {
									if (i > 0) {
										token_expect_symbol(list, ',');
									}
									var param_start_pos = token_get_pos(list);
									token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
									if (func_types) {
										if (func_types[i+1] == TYPE_DYNAMIC) {
											func_types[i+1] = gen->GEN_ret_type;
										}
										else {
											append_type_conv(gen, token_list(list), param_start_pos, func_types[i+1], gen->GEN_ret_type);
										}
									}
								}
								if (func_types) {
									token_expect_symbol(list, ')');
									token_next_nocheck(list);
									copy_func_tokens(gen, list);
									token_back(list);
									token_back(list);
									var end_pos = func_call_list[func_call_idx+FUNC_CALL_adjust_call_func](func_call_list[func_call_idx+FUNC_CALL_data], func_name, func_types, gen->GEN_func_tokens, list_src, call_start_pos - TOK_SIZE*2, length(gen->GEN_func_tokens));
									if (end_pos != length(gen->GEN_func_tokens)) {
										return 0, error({"invalid end position returned by other token processor at ", script_line(token_get_line(list))});
									}
									type = func_types[0];
								}
								token_expect_symbol(list, ')');
							}
						}
					}
					else {
						token_back(list);
					}
				}
			}
			//log({"var ", var_name, " type=", get_type_name(type), " line=", token_get_line(list)});
			if (type == -1) {
				type = TYPE_DYNAMIC;
				//return 0, error({script_line(token_get_line(list)), ": unknown variable ", var_name});
			}
			break;
		}
	}
}

function @add_completion(value, prefix)
{
	if (!prefix || string_starts_with(value, prefix)) {
		@fixide_add_completion(value);
	}
}

function @export_type(gen, type, prefix)
{
	var class = get_type_class_or_struct(type);
	if (class) {
		for (var i=0; i<length(class->CLASS_fields); i++) {
			var (name, field) = hash_entry(class->CLASS_fields, i);
			add_completion(name, prefix);
		}
		for (var i=0; i<length(class->CLASS_functions); i++) {
			var (name, func) = hash_entry(class->CLASS_functions, i);
			add_completion({func->FUNC_name, "()"}, prefix);
		}
	}
	else if (is_array(type)) {
		if (type[0] == EXT_TYPE_ARRAY) {
			add_completion("length", prefix);
			export_instance_functions(gen, "array_", prefix);
		}
		else if (type[0] == EXT_TYPE_HASH) {
			add_completion("length", prefix);
			export_instance_functions(gen, "hash_", prefix);
		}
		else if (type[0] == EXT_TYPE_STRUCT_ARRAY) {
			add_completion("first", prefix);
			add_completion("last", prefix);
			add_completion("length", prefix);
		}
	}
	else if (type == TYPE_STRING) {
		add_completion("length", prefix);
		export_instance_functions(gen, "string_", prefix);
	}
}

function @export_instance_functions(gen, func_prefix, prefix)
{
	var map = {};
	merge_hash(map, builtin_instance_functions);
	if (gen->GEN_imported_instance_functions) {
		merge_hash(map, gen->GEN_imported_instance_functions);
	}
	if (gen->GEN_instance_functions) {
		merge_hash(map, gen->GEN_instance_functions);
	}
	for (var i=0; i<length(map); i++) {
		var (name, func) = hash_entry(map, i);
		if (string_starts_with(name, func_prefix)) {
			add_completion({array_extract(func->FUNC_name, length(func_prefix), length(func->FUNC_name)-length(func_prefix)), "()"}, prefix);
		}
	}
}

macro @check_code_completion(type)
{
	if (fixide && gen->GEN_fixide_cursor >= 0) {
		var ident_prefix = null;
		if (token_next(list)) {
			if (token_get_type(list) == TOK_IDENT) {
				var token_off = token_get_offset(list);
				var token_len = token_get_length(list);
				if (gen->GEN_fixide_cursor >= token_off && gen->GEN_fixide_cursor <= token_off + token_len) {
					ident_prefix = token_get_value(list);
					array_set_length(ident_prefix, gen->GEN_fixide_cursor - token_off);
					export_type(gen, type, ident_prefix);
				}
			}
			token_back(list);
		}
		if (!ident_prefix) {
			if (token_get_offset(list)+1 == gen->GEN_fixide_cursor) {
				export_type(gen, type, null);
			}
		}
	}
}

macro @expression_primary_suffix()
{
	switch (token_get_type(list)) {
		case '.': {
			check_code_completion(type);
			if (type == TYPE_STRING || (is_array(type) && (type[0] == EXT_TYPE_ARRAY || type[0] == EXT_TYPE_HASH))) {
				token_expect_type(list, TOK_IDENT);
				var line = token_get_line(list);
				var name = token_get_value(list);

				token_expect_next(list);
				if (token_is_symbol(list, '(')) {
					var kind, generic_types;
					if (is_array(type) && type[0] == EXT_TYPE_ARRAY) {
						kind = "array";
						generic_types = [-1, type->ARRAY_base_type];
					}
					else if (type == TYPE_STRING) {
						kind = "string";
						generic_types = [-1, -1];
					}
					else if (is_array(type) && type[0] == EXT_TYPE_HASH) {
						kind = "hash";
						generic_types = [type->HASH_index_type, type->HASH_base_type];
					}

					token_back(list);
					token_back(list);
					copy_func_tokens(gen, list);
					token_next_nocheck(list);
					token_next_nocheck(list);
					var params_off = token_get_pos(list);
					token_expect_next(list);
					set_func_copy_start(gen, list);
				
					var num_params = 1;
					if (token_is_symbol(list, ')')) {
						token_back(list);
					}
					else {
						token_back(list);
						append_source(list_src, ",", &src_off);
						append_token(gen->GEN_func_tokens, ',', src_off, 1, line);
						for (;;) {
							num_params++;
							token_expect_expression(list);
							token_expect_next(list);
							if (token_is_symbol(list, ',')) continue;
							token_back(list);
							break;
						}
					}
					token_expect_symbol(list, ')');

					name = {kind, "_", name, "#", num_params};
					var func = null;
					if (gen->GEN_instance_functions) {
						func = hash_get(gen->GEN_instance_functions, name, null);
					}
					if (!func) {
						if (gen->GEN_imported_instance_functions) {
							func = hash_get(gen->GEN_imported_instance_functions, name, null);
						}
						if (!func) {
							func = hash_get(builtin_instance_functions, name, null);
						}
					}
					if (!func) {
						return 0, error({script_line(line), ": function ", name, " not found for ", kind, " type"});
					}

					var full_name = func->FUNC_alt_name? func->FUNC_alt_name : func->FUNC_name;
					append_source(list_src, {full_name, "("}, &src_off);
					var adj_off = max(off, unary_off);
					adj_off = hash_get(gen->GEN_func_offsets_replacements, adj_off, adj_off);
					insert_func_tokens(gen, list, adj_off, 2, &func_tokens, &func_pos);
					insert_token(func_tokens, func_pos, TOK_IDENT, src_off, length(full_name), line);
					insert_token(func_tokens, func_pos, '(', src_off+length(full_name), 1, line);

					var save_off = length(gen->GEN_func_tokens) - TOK_SIZE;
					var save_val = gen->GEN_func_tokens[save_off+TOK_off];
					gen->GEN_func_tokens[save_off+TOK_off] = list_tokens[params_off+TOK_off];

					token_set_pos(list, params_off);
					for (var i=1; i<num_params; i++) {
						if (i > 1) {
							token_expect_symbol(list, ',');
						}
						var (param_name, param_type) = hash_entry(func->FUNC_params, i);
						var param_start_pos = token_get_pos(list);
						token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
						param_type = apply_generic_types(param_type, generic_types, token_get_line(list));
						append_type_conv(gen, token_list(list), param_start_pos, param_type, gen->GEN_ret_type);
					}
					token_expect_symbol(list, ')');

					gen->GEN_func_tokens[save_off+TOK_off] = save_val;

					type = apply_generic_types(func->FUNC_return_type, generic_types, line);
					if (name == "hash_entry#2") {
						if (gen->GEN_hash_entry_value_type != -1) {
							return 0, error({script_line(line), ": both return values must be obtained for entry function"});
						}
						gen->GEN_hash_entry_value_type = apply_generic_types(TYPE_VALUE, generic_types, line);
					}
					continue;
				}
				else {
					token_back(list);
				}

				if (name == "length") {
					token_back(list);
					copy_func_tokens(gen, list);
					token_next_nocheck(list);
					token_next_nocheck(list);
					set_func_copy_start(gen, list);
					token_back(list);

					var adj_off = max(off, unary_off);
					adj_off = hash_get(gen->GEN_func_offsets_replacements, adj_off, adj_off);
					append_source(list_src, "length(", &src_off);
					insert_func_tokens(gen, list, adj_off, 2, &func_tokens, &func_pos);
					insert_token(func_tokens, func_pos, TOK_IDENT, src_off+0, 6, line);
					insert_token(func_tokens, func_pos, '(', src_off+6, 1, line);
					tokens_parse(gen->GEN_func_tokens, list_src, ")", line);

					gen->GEN_func_offsets_replacements{token_get_pos(list)} = -(length(gen->GEN_func_tokens)+TOK_SIZE);

					type = TYPE_INTEGER;
					continue;
				}
			}
			if (is_array(type)) {
				if (type[0] == EXT_TYPE_STRUCT_ARRAY) {
					token_expect_type(list, TOK_IDENT);
					var line = token_get_line(list);
					var name = token_get_value(list);
					if (name == "first") {
						var base_type = type->ARRAY_base_type;
						if (!is_array(base_type) || base_type[0] != EXT_TYPE_STRUCT) {
							return 0, error({script_line(token_get_line(list)), ": must be concrete struct array"});
						}

						token_back(list);
						copy_func_tokens(gen, list);
						token_next_nocheck(list);
						token_next_nocheck(list);
						set_func_copy_start(gen, list);
						token_back(list);

						var adj_off = max(off, unary_off);
						adj_off = hash_get(gen->GEN_func_offsets_replacements, adj_off, adj_off);
						insert_func_tokens(gen, list, adj_off, 0, &func_tokens, &func_pos);
						array_set_length(func_tokens, func_pos);
						tokens_parse(gen->GEN_func_tokens, list_src, {base_type->CLASS_compat_name, "_SIZE"}, line);
					
						gen->GEN_func_offsets_replacements{token_get_pos(list)} = -(length(gen->GEN_func_tokens)+TOK_SIZE);

						type = base_type;
						continue;
					}
					if (name == "last") {
						var base_type = type->ARRAY_base_type;
						if (!is_array(base_type) || base_type[0] != EXT_TYPE_STRUCT) {
							return 0, error({script_line(token_get_line(list)), ": must be concrete struct array"});
						}

						token_back(list);
						copy_func_tokens(gen, list);
						token_next_nocheck(list);
						token_next_nocheck(list);
						set_func_copy_start(gen, list);
						token_back(list);

						var adj_off = max(off, unary_off);
						adj_off = hash_get(gen->GEN_func_offsets_replacements, adj_off, adj_off);
						append_source(list_src, "length(", &src_off);
						insert_func_tokens(gen, list, adj_off, 2, &func_tokens, &func_pos);
						insert_token(func_tokens, func_pos, TOK_IDENT, src_off+0, 6, line);
						insert_token(func_tokens, func_pos, '(', src_off+6, 1, line);
						tokens_parse(gen->GEN_func_tokens, list_src, ")", line);

						gen->GEN_func_offsets_replacements{token_get_pos(list)} = -(length(gen->GEN_func_tokens)+TOK_SIZE);

						type = base_type;
						continue;
					}
					if (name == "length") {
						var base_type = type->ARRAY_base_type;
						if (!is_array(base_type) || base_type[0] != EXT_TYPE_STRUCT) {
							return 0, error({script_line(token_get_line(list)), ": must be concrete struct array"});
						}

						token_back(list);
						copy_func_tokens(gen, list);
						token_next_nocheck(list);
						token_next_nocheck(list);
						set_func_copy_start(gen, list);
						token_back(list);

						var adj_off = max(off, unary_off);
						adj_off = hash_get(gen->GEN_func_offsets_replacements, adj_off, adj_off);
						append_source(list_src, "(length(", &src_off);
						insert_func_tokens(gen, list, adj_off, 3, &func_tokens, &func_pos);
						insert_token(func_tokens, func_pos, '(', src_off+0, 1, line);
						insert_token(func_tokens, func_pos, TOK_IDENT, src_off+1, 6, line);
						insert_token(func_tokens, func_pos, '(', src_off+7, 1, line);
						tokens_parse(gen->GEN_func_tokens, list_src, {")/", base_type->CLASS_compat_name, "_SIZE", ")"}, line);

						gen->GEN_func_offsets_replacements{token_get_pos(list)} = -(length(gen->GEN_func_tokens)+TOK_SIZE);

						type = TYPE_INTEGER;
						continue;
					}
				}
			}
			var class = get_type_class_or_struct(type);
			if (!class) {
				return 0, error({script_line(token_get_line(list)), ": must be class or struct type"});
			}
			token_expect_type(list, TOK_IDENT);
			var line = token_get_line(list);
			var name = token_get_value(list);
			//log({"name=", name, " type=", class->CLASS_name});
			if (class->CLASS_ext_type == EXT_TYPE_STRUCT && name == "index") {
				token_back(list);
				copy_func_tokens(gen, list);
				token_next_nocheck(list);
				token_next_nocheck(list);
				set_func_copy_start(gen, list);
				token_back(list);

				var adj_off = max(off, unary_off);
				adj_off = hash_get(gen->GEN_func_offsets_replacements, adj_off, adj_off);
				append_source(list_src, "(sub32(", &src_off);
				insert_func_tokens(gen, list, adj_off, 3, &func_tokens, &func_pos);
				insert_token(func_tokens, func_pos, '(', src_off+0, 1, line);
				insert_token(func_tokens, func_pos, TOK_IDENT, src_off+1, 5, line);
				insert_token(func_tokens, func_pos, '(', src_off+6, 1, line);
				tokens_parse(gen->GEN_func_tokens, list_src, {", ", class->CLASS_compat_name, "_SIZE)/", class->CLASS_compat_name, "_SIZE)"}, line);

				type = TYPE_INTEGER;
				continue;
			}
			token_expect_next(list);
			if (token_is_symbol(list, '(')) {
				token_back(list);
				token_back(list);
				copy_func_tokens(gen, list);
				token_next_nocheck(list);
				token_next_nocheck(list);
				var params_off = token_get_pos(list);
				token_expect_next(list);
				set_func_copy_start(gen, list);
				
				var num_params = 1;
				if (token_is_symbol(list, ')')) {
					token_back(list);
				}
				else {
					token_back(list);
					append_source(list_src, ",", &src_off);
					append_token(gen->GEN_func_tokens, ',', src_off, 1, line);
					for (;;) {
						num_params++;
						token_expect_expression(list);
						token_expect_next(list);
						if (token_is_symbol(list, ',')) continue;
						token_back(list);
						break;
					}
				}
				token_expect_symbol(list, ')');

				name = {name, "#", num_params};
				var func, orig_class = class;
				while (class) {
					func = hash_get(class->CLASS_functions, name, null);
					if (func) {
						if (!(func->FUNC_flags & FUNC_FLAG_STATIC) && !(func->FUNC_flags & FUNC_FLAG_OVERRIDE) && (!(func->FUNC_flags & FUNC_FLAG_PRIVATE) || class === hash_get(gen->GEN_classes, class->CLASS_name, null))) {
							break;
						}
						func = null;
					}
					class = class->CLASS_parent;
				}
				if (!func) {
					return 0, error({script_line(line), ": function ", name, " not found in ", get_class_name_with_kind(orig_class)});
				}

				var real_name = {class->CLASS_method_prefix, func->FUNC_name};
				append_source(list_src, {real_name, "("}, &src_off);
				var adj_off = max(off, unary_off);
				adj_off = hash_get(gen->GEN_func_offsets_replacements, adj_off, adj_off);
				insert_func_tokens(gen, list, adj_off, 2, &func_tokens, &func_pos);
				insert_token(func_tokens, func_pos, TOK_IDENT, src_off, length(real_name), line);
				insert_token(func_tokens, func_pos, '(', src_off+length(real_name), 1, line);

				var save_off = length(gen->GEN_func_tokens) - TOK_SIZE;
				var save_val = gen->GEN_func_tokens[save_off+TOK_off];
				gen->GEN_func_tokens[save_off+TOK_off] = list_tokens[params_off+TOK_off];

				token_set_pos(list, params_off);
				for (var i=1; i<num_params; i++) {
					if (i > 1) {
						token_expect_symbol(list, ',');
					}
					var (param_name, param_type) = hash_entry(func->FUNC_params, i);
					var param_start_pos = token_get_pos(list);
					token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
					append_type_conv(gen, token_list(list), param_start_pos, param_type, gen->GEN_ret_type);
				}
				token_expect_symbol(list, ')');

				gen->GEN_func_tokens[save_off+TOK_off] = save_val;

				type = func->FUNC_return_type;
			}
			else {
				if (class->CLASS_ext_type != EXT_TYPE_CLASS) {
					return 0, error({script_line(token_get_line(list)), ": must be class type"});
				}
				var field, orig_class = class;
				while (class) {
					field = hash_get(class->CLASS_fields, name, null);
					if (field) {
						if (!field->FIELD_private || class === hash_get(gen->GEN_classes, class->CLASS_name, null)) {
							break;
						}
						field = null;
					}
					class = class->CLASS_parent;
				}
				if (!field) {
					token_back(list);
					return 0, error({script_line(line), ": can't find field '", name, "' in class ", orig_class->CLASS_name});
				}
				token_back(list);
				token_back(list);
				copy_func_tokens(gen, list);
				append_source(list_src, {"->", field->FIELD_compat_name}, &src_off);
				append_token(gen->GEN_func_tokens, '->', src_off, 2, line);
				append_token(gen->GEN_func_tokens, TOK_IDENT, src_off+2, length(field->FIELD_compat_name), line);
				token_next_nocheck(list);
				gen->GEN_func_offsets_replacements{token_get_pos(list)} = -(length(gen->GEN_func_tokens)+TOK_SIZE);
				token_next_nocheck(list);
				set_func_copy_start(gen, list);
				token_back(list);
				type = field->FIELD_type;
			}
			continue;
		}

		case '[': {
			token_next(list);
			if (token_is_symbol(list, ']')) {
				token_back(list);
				break;
			}
			token_back(list);
			var base_type = TYPE_DYNAMIC;
			var index_type = TYPE_INTEGER;
			var array = get_type_array_or_hash(type);
			var is_hash = false;
			var unsupported = false;
			if (array) {
				if (array[0] == EXT_TYPE_HASH) {
					base_type = array->HASH_base_type;
					index_type = array->HASH_index_type;
					is_hash = true;
				}
				else {
					base_type = array->ARRAY_base_type;
				}
			}
			else if (type == TYPE_STRING) {
				base_type = TYPE_INTEGER;
			}
			else if (is_array(type) && type[0] == EXT_TYPE_STRUCT_ARRAY) {
				base_type = TYPE_DYNAMIC;
			}
			else if (type != TYPE_DYNAMIC) {
				unsupported = true;
			}
			var off1 = token_get_offset(list);
			var expr_start_pos = token_get_pos(list);
			token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
			var struct_type = -1;
			if (is_array(gen->GEN_ret_type) && gen->GEN_ret_type[0] == EXT_TYPE_STRUCT) {
				struct_type = gen->GEN_ret_type;
				if (type != TYPE_DYNAMIC) {
					if (is_array(type) && type[0] == EXT_TYPE_ARRAY) {
						if (type->ARRAY_base_type != TYPE_DYNAMIC) {
							return 0, error({script_line(token_get_line(list)), ": can't access struct field in type ", get_type_name(type)});
						}
					}
					else if (is_array(type) && type[0] == EXT_TYPE_STRUCT_ARRAY) {
						if (type->ARRAY_base_type != TYPE_DYNAMIC && type->ARRAY_base_type !== struct_type) {
							return 0, error({script_line(token_get_line(list)), ": can't access struct field in an incompatible struct array"});
						}
					}
					else {
						if (unsupported) {
							var orig_pos = token_get_pos(list);
							if (token_next(list) && token_is_symbol(list, ']')) {
								if (token_next(list) && token_is_symbol(list, '.')) {
									var dot_pos = token_get_pos(list);
									if (token_next(list) && token_get_type(list) == TOK_IDENT) {
										var name = token_get_value(list);
										if (token_next(list) && token_is_symbol(list, '(')) {
											var line = token_get_line(list);
											var params_off = token_get_pos(list);
											token_expect_next(list);
											var num_params = 0;
											if (token_is_symbol(list, ')')) {
												token_back(list);
											}
											else {
												token_back(list);
												for (;;) {
													num_params++;
													token_expect_expression(list);
													token_expect_next(list);
													if (token_is_symbol(list, ',')) continue;
													token_back(list);
													break;
												}
											}
											token_expect_symbol(list, ')');
											token_set_pos(list, params_off);

											var func_name = {name, "#", num_params+2};
											var func = null;
											var struct = struct_type;
											for (;;) {
												func = hash_get(struct->CLASS_functions, func_name, null);
												if (func && (!(func->FUNC_flags & FUNC_FLAG_PRIVATE) || struct === hash_get(gen->GEN_classes, struct->CLASS_name, null))) {
													var (param_name, param_type) = hash_entry(func->FUNC_params, 1);
													if (param_type !== type) {
														return 0, error({script_line(token_get_line(list)), ": function ", func_name, " in struct ", get_type_name(struct_type), " has incompatible first parameter"});
													}
													break;
												}
												struct = struct->CLASS_parent;
												if (!struct) {
													return 0, error({script_line(token_get_line(list)), ": function ", func_name, " not found in struct ", get_type_name(struct_type)});
												}
											}

											token_set_pos(list, dot_pos);
											token_next_nocheck(list);
											copy_func_tokens(gen, list);
											token_back(list);

											var func_real_name = {struct->CLASS_method_prefix, name};
											append_source(list_src, {"(", func_real_name}, &src_off);
											insert_func_tokens(gen, list, off, 2, &func_tokens, &func_pos);
											insert_token(func_tokens, func_pos, TOK_IDENT, src_off+1, length(func_real_name), line);
											insert_token(func_tokens, func_pos, '(', src_off, 1, line);

											func_tokens = gen->GEN_func_tokens;
											var search_off1 = list_tokens[expr_start_pos+TOK_off];
											var search_off2 = list_tokens[dot_pos+TOK_off];
											var expr_pos1 = -1;
											var expr_pos2 = -1;
											for (var i=length(func_tokens)-TOK_SIZE; i>=0; i-=TOK_SIZE) {
												if (func_tokens[i+TOK_off] == search_off1) {
													expr_pos1 = i;
													break;
												}
												if (func_tokens[i+TOK_off] == search_off2) {
													expr_pos2 = i;
												}
											}
											var expr_tokens = array_extract(func_tokens, expr_pos1+TOK_SIZE, expr_pos2-expr_pos1-2*TOK_SIZE);
											array_remove(func_tokens, expr_pos1, expr_pos2-expr_pos1);

											tokens_parse(expr_tokens, list_src, ",", line);
											array_insert_array(func_tokens, func_pos, expr_tokens);

											var dot_off = length(func_tokens)-TOK_SIZE;
											if (num_params > 0) {
												append_source(list_src, ",", &src_off2);
												insert_token(func_tokens, dot_off, ',', src_off2, 1, line);
											}
											else {
												array_set_length(func_tokens, length(func_tokens)-TOK_SIZE);
											}

											token_set_pos(list, params_off);
											set_func_copy_start(gen, list);

											for (var i=0; i<num_params; i++) {
												if (i > 0) {
													token_expect_symbol(list, ',');
												}
												var (param_name, param_type) = hash_entry(func->FUNC_params, i+2);
												var param_start_pos = token_get_pos(list);
												token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
												append_type_conv(gen, token_list(list), param_start_pos, param_type, gen->GEN_ret_type);
											}
											token_expect_symbol(list, ')');

											token_next_nocheck(list);
											copy_func_tokens(gen, list);
											token_back(list);
											array_remove(func_tokens, dot_off, TOK_SIZE);

											type = func->FUNC_return_type;
											continue;
										}
									}
								}
							}
							token_set_pos(list, orig_pos);
						}
						return 0, error({script_line(token_get_line(list)), ": can't access struct field in type ", get_type_name(type)});
					}
				}
			}
			else {
				if (is_array(type) && type[0] == EXT_TYPE_STRUCT_ARRAY) {
					return 0, error({script_line(token_get_line(list)), ": can't access struct array directly"});
				}
				append_type_conv(gen, token_list(list), expr_start_pos, index_type, gen->GEN_ret_type);
			}
			if (unsupported) {
				return 0, error({script_line(token_get_line(list)), ": must be array or hash table"});
			}
			token_expect_symbol(list, ']');
			if (struct_type != -1) {
				token_expect_next(list);
				if (token_is_symbol(list, '=')) {
					var explicit_struct_name = false;

					token_expect_next(list);
					if (token_get_type(list) == TOK_IDENT) {
						token_expect_next(list);
						if (token_is_symbol(list, '{')) {
							explicit_struct_name = true;
							token_back(list);
							var name = token_get_value(list);
							var explicit_struct_type = find_class(gen, name);
							if (!explicit_struct_type) {
								return 0, error({script_line(token_get_line(list)), ": can't find struct ", name});
							}
							if (explicit_struct_type->CLASS_ext_type != EXT_TYPE_STRUCT) {
								return 0, error({script_line(token_get_line(list)), ": must be struct"});
							}
							if (struct_type != TYPE_DYNAMIC && struct_type !== explicit_struct_type) {
								return 0, error({script_line(token_get_line(list)), ": explicit ", get_class_name_with_kind(explicit_struct_type), " is different from ", get_class_name_with_kind(struct_type)});
							}
							struct_type = explicit_struct_type;
						}
						else {
							token_back(list);
							token_back(list);
						}
					}
					else {
						token_back(list);
					}

					if (struct_type == TYPE_DYNAMIC) {
						return 0, error({script_line(token_get_line(list)), ": struct type must be specified"});
					}

					var array_var = {"__classes_tmp_", tmp_cnt++};
					var index_var = {"__classes_tmp_", tmp_cnt++};
					var line = token_get_line(list);

					if (explicit_struct_name) token_back(list);
					token_back(list);
					copy_func_tokens(gen, list);
					token_next_nocheck(list);
					if (explicit_struct_name) token_next_nocheck(list);

					insert_func_tokens(gen, list, off, 4, &func_tokens, &func_pos);
					append_source(list_src, {"{var", array_var, "="}, &src_off);
					insert_token(func_tokens, func_pos, '{', src_off+0, 1, line);
					insert_token(func_tokens, func_pos, KW_VAR, src_off+1, 3, line);
					insert_token(func_tokens, func_pos, TOK_IDENT, src_off+4, length(array_var), line);
					insert_token(func_tokens, func_pos, '=', src_off+4+length(array_var), 1, line);

					insert_func_tokens(gen, list, expr_start_pos, 5, &func_tokens2, &func_pos2);
					func_pos2 -= TOK_SIZE;
					array_remove(func_tokens2, func_pos2, TOK_SIZE);
					append_source(list_src, {",", index_var, "=sub32("}, &src_off2);
					insert_token(func_tokens2, func_pos2, ',', src_off2+0, 1, line);
					insert_token(func_tokens2, func_pos2, TOK_IDENT, src_off2+1, length(index_var), line);
					insert_token(func_tokens2, func_pos2, '=', src_off2+1+length(index_var), 1, line);
					insert_token(func_tokens2, func_pos2, TOK_IDENT, src_off2+1+length(index_var)+1, 5, line);
					insert_token(func_tokens2, func_pos2, '(', src_off2+1+length(index_var)+6, 1, line);

					token_expect_symbol(list, '{');
					token_next_nocheck(list);
					set_func_copy_start(gen, list);
					token_back(list);

					tokens_parse(gen->GEN_func_tokens, list_src, {",", struct_type->CLASS_compat_name, "_SIZE);"}, token_get_line(list));

					var fields = {};
					var value_pos = length(gen->GEN_func_tokens);
					token_expect_next(list);
					if (token_is_symbol(list, '.')) {
						token_back(list);
						for (;;) {
							token_expect_symbol(list, '.');
							token_expect_type(list, TOK_IDENT);
							var name = token_get_value(list);
							if (hash_contains(fields, name)) {
								return 0, error({script_line(token_get_line(list)), ": duplicate field"});
							}
							var (field_type, offset) = get_struct_field(gen, struct_type, name);
							if (!is_int(offset)) {
								return 0, offset;
							}
							token_expect_symbol(list, ':');
							set_func_copy_start(gen, list);
							var field_value_pos = token_get_pos(list);
							token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
							append_type_conv(gen, token_list(list), field_value_pos, field_type, gen->GEN_ret_type);
							line = token_get_line(list);
							token_expect_next(list);
							copy_func_tokens(gen, list);

							fields{name} = array_extract(gen->GEN_func_tokens, value_pos + TOK_SIZE, length(gen->GEN_func_tokens) - value_pos - TOK_SIZE);
							array_set_length(gen->GEN_func_tokens, value_pos);

							if (token_get_type(list) == ',') continue;
							token_back(list);
							break;
						}
					}
					else {
						token_back(list);
					}

					var cls = struct_type;
					var new_tokens = [], all_tokens = [];
					while (cls) {
						var cls_fields = cls->CLASS_fields;
						for (var i=0; i<length(cls_fields); i++) {
							var (k, v) = hash_entry(cls_fields, i);
							tokens_parse(new_tokens, list_src, {array_var, "[", index_var, "++]="}, token_get_line(list));
							var tokens = hash_get(fields, k, null);
							if (tokens) {
								hash_remove(fields, k);
								array_append(new_tokens, tokens);
							}
							else {
								tokens_parse(new_tokens, list_src, "0", line);
							}
							tokens_parse(new_tokens, list_src, ";", line);
						}
						array_insert_array(all_tokens, 0, new_tokens);
						array_clear(new_tokens);
						cls = cls->CLASS_parent;
					}

					if (length(fields) != 0) {
						var (k, v) = hash_entry(fields, 0);
						return 0, error({script_line(token_get_line(list)), ": unknown field ", k, " in ", get_class_name_with_kind(struct_type)});
					}

					array_append(gen->GEN_func_tokens, all_tokens);
					token_expect_symbol(list, '}');
					continue;
				}
				token_back(list);
				token_expect_symbol(list, '.');
				var dot_pos = token_get_pos(list);
				token_back(list);
				copy_func_tokens(gen, list);
				token_next_nocheck(list);
				token_expect_type(list, TOK_IDENT);
				var name = token_get_value(list);
				token_expect_next(list);
				if (token_is_symbol(list, '(')) {
					var line = token_get_line(list);
					var params_off = token_get_pos(list);
					token_expect_next(list);
					var num_params = 0;
					if (token_is_symbol(list, ')')) {
						token_back(list);
					}
					else {
						token_back(list);
						for (;;) {
							num_params++;
							token_expect_expression(list);
							token_expect_next(list);
							if (token_is_symbol(list, ',')) continue;
							token_back(list);
							break;
						}
					}
					token_expect_symbol(list, ')');
					token_set_pos(list, params_off);
		
					var func_name = {name, "#", num_params+2};
					var func = null;
					var struct = struct_type;
					for (;;) {
						func = hash_get(struct->CLASS_functions, func_name, null);
						if (func && (!(func->FUNC_flags & FUNC_FLAG_PRIVATE) || struct === hash_get(gen->GEN_classes, struct->CLASS_name, null))) {
							var (param_name, param_type) = hash_entry(func->FUNC_params, 1);
							if (!is_array(param_type) || param_type[0] != EXT_TYPE_STRUCT_ARRAY || (param_type->ARRAY_base_type != TYPE_DYNAMIC && param_type->ARRAY_base_type !== struct_type)) {
								return 0, error({script_line(token_get_line(list)), ": function ", func_name, " in struct ", get_type_name(struct_type), " has incompatible first parameter"});
							}
							break;
						}
						struct = struct->CLASS_parent;
						if (!struct) {
							return 0, error({script_line(token_get_line(list)), ": function ", func_name, " not found in struct ", get_type_name(struct_type)});
						}
					}

					token_set_pos(list, dot_pos);
					token_next_nocheck(list);
					copy_func_tokens(gen, list);
					token_back(list);

					var func_real_name = {struct->CLASS_method_prefix, name};
					append_source(list_src, {"(", func_real_name}, &src_off);
					insert_func_tokens(gen, list, off, 2, &func_tokens, &func_pos);
					insert_token(func_tokens, func_pos, TOK_IDENT, src_off+1, length(func_real_name), line);
					insert_token(func_tokens, func_pos, '(', src_off, 1, line);

					func_tokens = gen->GEN_func_tokens;
					var search_off1 = list_tokens[expr_start_pos+TOK_off];
					var search_off2 = list_tokens[dot_pos+TOK_off];
					var expr_pos1 = -1;
					var expr_pos2 = -1;
					for (var i=length(func_tokens)-TOK_SIZE; i>=0; i-=TOK_SIZE) {
						if (func_tokens[i+TOK_off] == search_off1) {
							expr_pos1 = i;
							break;
						}
						if (func_tokens[i+TOK_off] == search_off2) {
							expr_pos2 = i;
						}
					}
					var expr_tokens = array_extract(func_tokens, expr_pos1+TOK_SIZE, expr_pos2-expr_pos1-2*TOK_SIZE);
					array_remove(func_tokens, expr_pos1, expr_pos2-expr_pos1);

					tokens_parse(expr_tokens, list_src, ",", line);
					array_insert_array(func_tokens, func_pos, expr_tokens);

					var dot_off = length(func_tokens)-TOK_SIZE;
					if (num_params > 0) {
						append_source(list_src, ",", &src_off2);
						insert_token(func_tokens, dot_off, ',', src_off2, 1, line);
					}
					else {
						array_set_length(func_tokens, length(func_tokens)-TOK_SIZE);
					}

					token_set_pos(list, params_off);
					set_func_copy_start(gen, list);

					for (var i=0; i<num_params; i++) {
						if (i > 0) {
							token_expect_symbol(list, ',');
						}
						var (param_name, param_type) = hash_entry(func->FUNC_params, i+2);
						var param_start_pos = token_get_pos(list);
						token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
						append_type_conv(gen, token_list(list), param_start_pos, param_type, gen->GEN_ret_type);
					}
					token_expect_symbol(list, ')');

					token_next_nocheck(list);
					copy_func_tokens(gen, list);
					token_back(list);
					array_remove(func_tokens, dot_off, TOK_SIZE);

					type = func->FUNC_return_type;
				}
				else {
					token_back(list);
					var (field_type, offset) = get_struct_field(gen, struct_type, name);
					if (!is_int(offset)) {
						return 0, offset;
					}
					if (offset < 0) {
						return 0, error({script_line(token_get_line(list)), ": can't find field ", name, " in struct ", struct_type->CLASS_name});
					}
					var line = token_get_line(list);
					var prepend = tokens_parse([], list_src, "sub32(", line);
					insert_func_tokens(gen, list, expr_start_pos, 2, &func_tokens, &func_pos);
					array_copy(func_tokens, func_pos, prepend, 0, length(prepend));
					tokens_parse(gen->GEN_func_tokens, list_src, {", ", offset, ")"}, line);
					token_back(list);
					token_back(list);
					set_func_copy_start(gen, list);
					token_next_nocheck(list);
					copy_func_tokens(gen, list);
					token_next_nocheck(list);
					token_next_nocheck(list);
					set_func_copy_start(gen, list);
					token_back(list);
					type = field_type;
					if (type == TYPE_FLOAT) {
						var is_assign = false;
						token_expect_next(list);
						switch (token_get_type(list)) {
							case '=', '+=', '-=', '*=', '/=':
								is_assign = true;
								break;
						}
						token_back(list);
						if (!is_assign) {
							append_source(list_src, "{(", &src_off);
							var adj_off = max(off, unary_off);
							adj_off = hash_get(gen->GEN_func_offsets_replacements, adj_off, adj_off);
							insert_func_tokens(gen, list, adj_off, 2, &func_tokens2, &func_pos2);
							insert_token(func_tokens2, func_pos2, '{', src_off, 1, line);
							insert_token(func_tokens2, func_pos2, '(', src_off+1, 1, line);
							tokens_parse(gen->GEN_func_tokens, list_src, ")*1.0}", line);
						}
					}
				}
				continue;
			}
			var off2 = token_get_offset(list);
			if (is_hash) {
				token_next_nocheck(list);
				copy_func_tokens(gen, list);
				token_back(list);
				append_source(list_src, "{}", &src_off);
				var func_tokens = gen->GEN_func_tokens;
				for (var i=length(func_tokens)-TOK_SIZE; ; i-=TOK_SIZE) {
					var foff = func_tokens[i+TOK_off];
					if (foff == off2) {
						func_tokens[i+TOK_type] = '}';
						func_tokens[i+TOK_off] = src_off+1;
						continue;
					}
					if (foff == off1) {
						func_tokens[i+TOK_type] = '{';
						func_tokens[i+TOK_off] = src_off;
						break;
					}
				}
			}
			type = base_type;
			continue;
		}

		case '{': {
			var expr_start_pos = token_get_pos(list);
			token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
			append_type_conv(gen, token_list(list), expr_start_pos, TYPE_DYNAMIC, gen->GEN_ret_type);
			token_expect_symbol(list, '}');
			type = TYPE_DYNAMIC;
			continue;
		}

		case '(':
			token_expect_next(list);
			if (!token_is_symbol(list, ')')) {
				token_back(list);
				for (;;) {
					token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
					token_expect_next(list);
					if (token_is_symbol(list, ',')) continue;
					token_back(list);
					break;
				}
				token_expect_symbol(list, ')');
			}
			type = TYPE_DYNAMIC;
			continue;

		case '->':
			token_expect_type(list, TOK_IDENT);
			type = TYPE_DYNAMIC;
			continue;
	}
}

macro @find_operator(&operator_list, &operator_off, type1, type2, prio)
{
	var $key = get_operator_key(type1, type2, prio);
	var $list = hash_get(gen->GEN_imported_operators, $key, null);
	if ($list) {
		var found = false;
		for (var $i=0; $i<length($list); $i+=OPERATOR_SIZE) {
			if ($list[$i+OPERATOR_prio] !== prio) continue;
			if ($list[$i+OPERATOR_type1] !== type1) continue;
			if ($list[$i+OPERATOR_type2] !== type2) continue;
			operator_list = $list;
			operator_off = $i;
			break;
		}
	}
}

macro @handle_operators()
{
	if (is_array(prev_type) || is_array(type)) {
		var operator_list, operator_off;
		find_operator(&operator_list, &operator_off, prev_type, type, prio);
		if (!operator_list) {
			find_operator(&operator_list, &operator_off, prev_type, TYPE_DYNAMIC, prio);
			if (!operator_list) {
				find_operator(&operator_list, &operator_off, TYPE_DYNAMIC, type, prio);
			}
		}
		if (operator_list) {
			token_next_nocheck(list);
			copy_func_tokens(gen, list);
			token_back(list);
			wrap_operator_op(gen, token_list(list), start_pos, off, operator_list[operator_off+OPERATOR_func_name], operator_list[operator_off+OPERATOR_compare], prio);
			type = operator_list[operator_off+OPERATOR_ret_type];
			break;
		}
	}
}

macro @expression_operators(last_pos)
{
	switch (prio) {
		case PRIO_ADDITIVE_ADD .. PRIO_ADDITIVE_SUB, PRIO_MULTIPLICATIVE_MUL .. PRIO_MULTIPLICATIVE_REM: {
			//log({"type1=", get_type_name(prev_type), " type2=", get_type_name(type)});
			if (prio == PRIO_ADDITIVE_ADD && (prev_type == TYPE_STRING || type == TYPE_STRING)) {
				token_next_nocheck(list);
				copy_func_tokens(gen, list);
				token_back(list);
				if (is_array(prev_type) && prev_type[0] == EXT_TYPE_CLASS) {
					var to_string_cls = find_to_string_function(prev_type);
					if (to_string_cls) {
						var line = token_get_line(list);
						var prepend = {to_string_cls->CLASS_method_prefix, "to_string("};
						insert_func_tokens(gen, list, start_pos, 2, &func_tokens, &func_pos);
						append_source(list_src, prepend, &src_off);
						insert_token(func_tokens, func_pos, TOK_IDENT, src_off, length(prepend)-1, line);
						insert_token(func_tokens, func_pos, '(', src_off+length(prepend)-1, 1, line);
						insert_func_tokens_adj(gen, list, off, -TOK_SIZE, 1, &func_tokens2, &func_pos2);
						append_source(list_src, ")", &src_off2);
						insert_token(func_tokens2, func_pos2, ')', src_off2, 1, line);
					}
				}
				else if (is_array(type) && type[0] == EXT_TYPE_CLASS) {
					var to_string_cls = find_to_string_function(type);
					if (to_string_cls) {
						var line = token_get_line(list);
						var prepend = {to_string_cls->CLASS_method_prefix, "to_string("};
						insert_func_tokens(gen, list, off, 2, &func_tokens, &func_pos);
						append_source(list_src, prepend, &src_off);
						insert_token(func_tokens, func_pos, TOK_IDENT, src_off, length(prepend)-1, line);
						insert_token(func_tokens, func_pos, '(', src_off+length(prepend)-1, 1, line);
						tokens_parse(gen->GEN_func_tokens, list_src, ")", line);
					}
				}
				wrap_concat_op(gen, token_list(list), start_pos, off);
				type = TYPE_STRING;
				break;
			}
			else if (prio == PRIO_ADDITIVE_ADD || prio == PRIO_ADDITIVE_SUB) {
				if (is_array(prev_type) && prev_type[0] == EXT_TYPE_STRUCT && (type == TYPE_INTEGER || type == TYPE_DYNAMIC)) {
					token_next_nocheck(list);
					copy_func_tokens(gen, list);
					token_back(list);

					var line = token_get_line(list);
					append_source(list_src, "((", &src_off);
					insert_func_tokens(gen, list, off, 2, &func_tokens, &func_pos);
					insert_token(func_tokens, func_pos, '(', src_off, 1, line);
					insert_token(func_tokens, func_pos, '(', src_off+1, 1, line);
					tokens_parse(gen->GEN_func_tokens, list_src, {")*", prev_type->CLASS_compat_name, "_SIZE)"}, token_get_line(list));

					type = prev_type;
					break;
				}
				else if (is_array(type) && type[0] == EXT_TYPE_STRUCT && (prev_type == TYPE_INTEGER || prev_type == TYPE_DYNAMIC)) {
					token_next_nocheck(list);
					copy_func_tokens(gen, list);
					token_back(list);

					var line = token_get_line(list);
					var size_const = {type->CLASS_compat_name, "_SIZE"};
					append_source(list_src, {"(())*", size_const}, &src_off);
					insert_func_tokens(gen, list, start_pos, 2, &func_tokens, &func_pos);
					insert_token(func_tokens, func_pos, '(', src_off, 1, line);
					insert_token(func_tokens, func_pos, '(', src_off+1, 1, line);

					insert_func_tokens_adj(gen, list, off, -TOK_SIZE, 4, &func_tokens2, &func_pos2);
					insert_token(func_tokens2, func_pos2, ')', src_off+2, 1, line);
					insert_token(func_tokens2, func_pos2, '*', src_off+4, 1, line);
					insert_token(func_tokens2, func_pos2, TOK_IDENT, src_off+5, length(size_const), line);
					insert_token(func_tokens2, func_pos2, ')', src_off+3, 1, line);
					break;
				}
			}

			handle_operators();

			if (prev_type == TYPE_FLOAT && type != TYPE_FLOAT) {
				if (type != TYPE_INTEGER) {
					return 0, error({script_line(token_get_line(list)), ": not an Integer or Float"});
				}
				token_next_nocheck(list);
				wrap_with_float_conv(gen, token_list(list), off, -1);
				token_back(list);
				type = TYPE_FLOAT;
			}
			else if (type == TYPE_FLOAT && prev_type != TYPE_FLOAT) {
				if (prev_type != TYPE_INTEGER) {
					return 0, error({script_line(token_get_line(list)), ": not an Integer or Float"});
				}
				token_next_nocheck(list);
				var adj_last_pos = hash_get(gen->GEN_func_offsets_replacements, last_pos, last_pos);
				wrap_with_float_conv(gen, token_list(list), start_pos, adj_last_pos);
				token_back(list);
			}
			if ((type != TYPE_DYNAMIC && type != TYPE_INTEGER && type != TYPE_FLOAT) ||
			    (prev_type != TYPE_DYNAMIC && prev_type != TYPE_INTEGER && prev_type != TYPE_FLOAT))
			{
				return 0, error({script_line(token_get_line(list)), ": incompatible type for arithmetic operation"});
			}

			if (type == TYPE_FLOAT) {
				token_next_nocheck(list);
				copy_func_tokens(gen, list);
				token_back(list);
				wrap_float_op(gen, token_list(list), start_pos);
			}
			break;
		}

		case PRIO_BITWISE_AND .. PRIO_BITWISE_USHR: {
			handle_operators();
			if (prev_type != TYPE_DYNAMIC && prev_type != TYPE_INTEGER) {
				return 0, error({script_line(token_get_line(list)), ": not an Integer"});
			}
			if (type != TYPE_DYNAMIC && type != TYPE_INTEGER) {
				return 0, error({script_line(token_get_line(list)), ": not an Integer"});
			}
			type = TYPE_INTEGER;
			break;
		}

		case PRIO_LOGICAL_AND .. PRIO_LOGICAL_OR: {
			handle_operators();
			if (prev_type != TYPE_DYNAMIC && prev_type != TYPE_BOOLEAN) {
				return 0, error({script_line(token_get_line(list)), ": not an Boolean"});
			}
			if (type != TYPE_DYNAMIC && type != TYPE_BOOLEAN) {
				return 0, error({script_line(token_get_line(list)), ": not an Boolean"});
			}
			type = TYPE_BOOLEAN;
			break;
		}

		case PRIO_COMPARISON_LT .. PRIO_COMPARISON_GE: {
			handle_operators();
			if (prev_type == TYPE_INTEGER && type == TYPE_DYNAMIC) {
				// ok
			}
			else if (prev_type == TYPE_DYNAMIC && type == TYPE_INTEGER) {
				// ok
			}
			else if (prev_type == TYPE_INTEGER && type == TYPE_INTEGER) {
				// ok
			}
			else if (prev_type == TYPE_FLOAT && type == TYPE_FLOAT) {
				token_next_nocheck(list);
				copy_func_tokens(gen, list);
				token_back(list);
				wrap_float_op(gen, token_list(list), start_pos);
			}
			else {
				var is_struct1 = is_array(prev_type) && prev_type[0] == EXT_TYPE_STRUCT;
				var is_struct2 = is_array(type) && type[0] == EXT_TYPE_STRUCT;
				if ((is_struct1 && is_struct2) ||
				    (is_struct1 && (type == TYPE_INTEGER || type == TYPE_DYNAMIC)) ||
				    (is_struct2 && (prev_type == TYPE_INTEGER || prev_type == TYPE_DYNAMIC)))
				{
					if (is_struct1 && is_struct2 && prev_type != type) {
						return 0, error({script_line(token_get_line(list)), ": cannot compare incompatible structures"});
					}
					token_next_nocheck(list);
					copy_func_tokens(gen, list);
					token_back(list);
					if (is_struct1 && !is_struct2) {
						wrap_struct_conv(gen, token_list(list), start_pos, off, prev_type);
					}
					if (is_struct2 && !is_struct1) {
						wrap_struct_conv(gen, token_list(list), off, -1, type);
					}
				}
				else {
					return 0, error({script_line(token_get_line(list)), ": cannot compare incompatible types"});
				}
			}
			type = TYPE_BOOLEAN;
			break;
		}

		case PRIO_EQUALITY_EQ_VALUE .. PRIO_EQUALITY_NE_REF: {
			if (prio == PRIO_EQUALITY_EQ_VALUE || prio == PRIO_EQUALITY_NE_VALUE) {
				handle_operators();
			}
			if (prev_type == TYPE_FLOAT && type != TYPE_FLOAT) {
				if (type != TYPE_INTEGER) {
					return 0, error({script_line(token_get_line(list)), ": not an Integer or Float"});
				}
				token_next_nocheck(list);
				wrap_with_float_conv(gen, token_list(list), off, -1);
				wrap_float_op(gen, token_list(list), start_pos);
				token_back(list);
			}
			else if (type == TYPE_FLOAT && prev_type != TYPE_FLOAT) {
				if (prev_type != TYPE_INTEGER) {
					return 0, error({script_line(token_get_line(list)), ": not an Integer or Float"});
				}
				token_next_nocheck(list);
				wrap_with_float_conv(gen, token_list(list), start_pos, last_pos);
				wrap_float_op(gen, token_list(list), start_pos);
				token_back(list);
			}
			else {
				var is_struct1 = is_array(prev_type) && prev_type[0] == EXT_TYPE_STRUCT;
				var is_struct2 = is_array(type) && type[0] == EXT_TYPE_STRUCT;
				if (is_struct1 && is_struct2) {
					if (prev_type != type) {
						return 0, error({script_line(token_get_line(list)), ": cannot compare incompatible structures"});
					}
				}
				else if ((is_struct1 && (type == TYPE_INTEGER || type == TYPE_DYNAMIC)) ||
				         (is_struct2 && (prev_type == TYPE_INTEGER || prev_type == TYPE_DYNAMIC)))
				{
					token_next_nocheck(list);
					copy_func_tokens(gen, list);
					token_back(list);
					if (is_struct1) {
						wrap_struct_conv(gen, token_list(list), start_pos, off, prev_type);
					}
					if (is_struct2) {
						wrap_struct_conv(gen, token_list(list), off, -1, type);
					}
				}
			}
			type = TYPE_BOOLEAN;
			break;
		}
	}
}

macro @expression_assignment()
{
	var assignment = 0;
	var op_prio = -1;
	switch (token_get_type(list)) {
		case '=': assignment = 2; break;
		case '[':
			token_expect_next(list);
			if (token_is_symbol(list, ']')) {
				assignment = 1;
				token_expect_symbol(list, '=');
				var struct_type = -1;
				var explicit_struct_name = false;
				if (type == TYPE_DYNAMIC) {
					struct_type = TYPE_DYNAMIC;
				}
				else if (is_array(type)) {
					var ext_type = type[0];
					if (ext_type == EXT_TYPE_ARRAY && type->ARRAY_base_type == TYPE_DYNAMIC) {
						struct_type = TYPE_DYNAMIC;
					}
					else if (ext_type == EXT_TYPE_STRUCT_ARRAY) {
						struct_type = type->ARRAY_base_type;
					}
				}
				if (struct_type != -1) {
					token_expect_next(list);
					if (token_get_type(list) == TOK_IDENT) {
						token_expect_next(list);
						if (token_is_symbol(list, '{')) {
							explicit_struct_name = true;
							token_back(list);
							var name = token_get_value(list);
							var explicit_struct_type = find_class(gen, name);
							if (!explicit_struct_type) {
								return 0, error({script_line(token_get_line(list)), ": can't find struct ", name});
							}
							if (explicit_struct_type->CLASS_ext_type != EXT_TYPE_STRUCT) {
								return 0, error({script_line(token_get_line(list)), ": must be struct"});
							}
							if (struct_type != TYPE_DYNAMIC && struct_type !== explicit_struct_type) {
								return 0, error({script_line(token_get_line(list)), ": explicit ", get_class_name_with_kind(explicit_struct_type), " is different from ", get_class_name_with_kind(struct_type)});
							}
							struct_type = explicit_struct_type;
						}
						else {
							token_back(list);
							token_back(list);
						}
					}
					else {
						token_back(list);
					}
					if (struct_type == TYPE_DYNAMIC) {
						break;
					}
					var array_var = {"__classes_tmp_", tmp_cnt++};
					var line = token_get_line(list);
					if (explicit_struct_name) token_back(list);
					token_back(list);
					token_back(list);
					copy_func_tokens(gen, list);
					var adj_off = hash_get(gen->GEN_func_offsets_replacements, off, off);
					insert_func_tokens(gen, list, adj_off, 4, &func_tokens, &func_pos);
					append_source(list_src, {"{var", array_var, "="}, &src_off);
					insert_token(func_tokens, func_pos, '{', src_off+0, 1, line);
					insert_token(func_tokens, func_pos, KW_VAR, src_off+1, 3, line);
					insert_token(func_tokens, func_pos, TOK_IDENT, src_off+4, length(array_var), line);
					insert_token(func_tokens, func_pos, '=', src_off+4+length(array_var), 1, line);
					token_next_nocheck(list);
					token_next_nocheck(list);
					if (explicit_struct_name) token_next_nocheck(list);
					tokens_parse(gen->GEN_func_tokens, list_src, ";", line);
					token_expect_symbol(list, '{');
					token_next_nocheck(list);
					set_func_copy_start(gen, list);
					token_back(list);

					var fields = {};
					var value_pos = length(gen->GEN_func_tokens);
					token_expect_next(list);
					if (token_is_symbol(list, '.')) {
						token_back(list);
						for (;;) {
							token_expect_symbol(list, '.');
							token_expect_type(list, TOK_IDENT);
							var name = token_get_value(list);
							if (hash_contains(fields, name)) {
								return 0, error({script_line(token_get_line(list)), ": duplicate field"});
							}
							var (field_type, offset) = get_struct_field(gen, struct_type, name);
							if (!is_int(offset)) {
								return 0, offset;
							}
							token_expect_symbol(list, ':');
							set_func_copy_start(gen, list);
							var field_value_pos = token_get_pos(list);
							token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
							append_type_conv(gen, token_list(list), field_value_pos, field_type, gen->GEN_ret_type);
							line = token_get_line(list);
							token_expect_next(list);
							copy_func_tokens(gen, list);

							fields{name} = array_extract(gen->GEN_func_tokens, value_pos + TOK_SIZE, length(gen->GEN_func_tokens) - value_pos - TOK_SIZE);
							array_set_length(gen->GEN_func_tokens, value_pos);

							if (token_get_type(list) == ',') continue;
							token_back(list);
							break;
						}
					}
					else {
						token_back(list);
					}

					var cls = struct_type;
					var new_tokens = [], all_tokens = [];
					while (cls) {
						var cls_fields = cls->CLASS_fields;
						for (var i=0; i<length(cls_fields); i++) {
							var (k, v) = hash_entry(cls_fields, i);
							tokens_parse(new_tokens, list_src, {array_var, "[]="}, token_get_line(list));
							var tokens = hash_get(fields, k, null);
							if (tokens) {
								hash_remove(fields, k);
								array_append(new_tokens, tokens);
							}
							else {
								tokens_parse(new_tokens, list_src, "0", line);
							}
							tokens_parse(new_tokens, list_src, ";", line);
						}
						array_insert_array(all_tokens, 0, new_tokens);
						array_clear(new_tokens);
						cls = cls->CLASS_parent;
					}

					if (length(fields) != 0) {
						var (k, v) = hash_entry(fields, 0);
						return 0, error({script_line(token_get_line(list)), ": unknown field ", k, " in ", get_class_name_with_kind(struct_type)});
					}

					array_append(gen->GEN_func_tokens, all_tokens);
					token_expect_symbol(list, '}');
					assignment = -1;
				}
				break;
			}
			else {
				token_back(list);
			}
			break;

		case '+=': { assignment = 3; op_prio = PRIO_SPECIAL_ADD_INPLACE; break; }
		case '-=': { assignment = 3; op_prio = PRIO_SPECIAL_SUB_INPLACE; break; }
		case '*=': { assignment = 3; op_prio = PRIO_SPECIAL_MUL_INPLACE; break; }
		case '/=': { assignment = 3; op_prio = PRIO_SPECIAL_DIV_INPLACE; break; }
		case '%=': { assignment = 3; op_prio = PRIO_SPECIAL_REM_INPLACE; break; }
		case '&=': { assignment = 3; op_prio = PRIO_SPECIAL_AND_INPLACE; break; }
		case '|=': { assignment = 3; op_prio = PRIO_SPECIAL_OR_INPLACE; break; }
		case '^=': { assignment = 3; op_prio = PRIO_SPECIAL_XOR_INPLACE; break; }
		case '<<=': { assignment = 3; op_prio = PRIO_SPECIAL_SHL_INPLACE; break; }
		case '>>=': { assignment = 3; op_prio = PRIO_SPECIAL_SHR_INPLACE; break; }
		case '>>>=': { assignment = 3; op_prio = PRIO_SPECIAL_USHR_INPLACE; break; }
	}

	if (assignment) {
		if (assignment == -1) {
			break;
		}
		if (prev_type != -1) {
			return 0, error({script_line(token_get_line(list)), ": invalid assignment"});
		}
		var value_pos = token_get_pos(list);
		prev_type = type;

		if (assignment == 3 && prev_type == TYPE_FLOAT) {
			var op_type = token_get_type(list);
			if (op_type != '+=' && op_type != '-=' && op_type != '*=' && op_type != '/=') {
				return 0, error({script_line(token_get_line(list)), ": unsupported arithmetic operation for floats"});
			}
			copy_func_tokens(gen, list);
			var op_pos = length(gen->GEN_func_tokens);

			token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
			type = gen->GEN_ret_type;
			if (type == TYPE_INTEGER) {
				append_type_conv(gen, token_list(list), value_pos, TYPE_FLOAT, type);
				type = TYPE_FLOAT;
			}
			else if (type != TYPE_FLOAT) {
				return 0, error({script_line(token_get_line(list)), ": not an Integer or Float"});
			}

			token_next_nocheck(list);
			copy_func_tokens(gen, list);
			token_back(list);
			gen->GEN_func_tokens[op_pos] |= 'f' << 16;
			gen->GEN_uses_float_shorthands = true;
		}
		else if (assignment == 3 && prev_type == TYPE_STRING && token_get_type(list) == '+=') {
			copy_func_tokens(gen, list);
			var line = token_get_line(list);
			var adj_off = hash_get(gen->GEN_func_offsets_replacements, off, off);
			insert_func_tokens(gen, list, adj_off, 2, &func_tokens, &func_pos);
			append_source(list_src, "array_append(,", &src_off);
			insert_token(func_tokens, func_pos, TOK_IDENT, src_off, 12, line);
			insert_token(func_tokens, func_pos, '(', src_off+12, 1, line);
			var comma_pos = list_off;
			insert_token(list_tokens, comma_pos, ',', src_off+13, 1, line);
			token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
			token_next_nocheck(list);
			copy_func_tokens(gen, list);
			token_back(list);
			var ret_type = gen->GEN_ret_type;
			if (ret_type != TYPE_STRING) {
				if (is_array(ret_type) && ret_type[0] == EXT_TYPE_CLASS) {
					var to_string_cls = find_to_string_function(ret_type);
					if (to_string_cls) {
						var prepend = {to_string_cls->CLASS_method_prefix, "to_string("};
						insert_func_tokens(gen, list, value_pos, 2, &func_tokens2, &func_pos2);
						append_source(list_src, prepend, &src_off2);
						insert_token(func_tokens2, func_pos2, TOK_IDENT, src_off2, length(prepend)-1, line);
						insert_token(func_tokens2, func_pos2, '(', src_off2+length(prepend)-1, 1, line);
						tokens_parse(gen->GEN_func_tokens, list_src, ")", line);
					}
				}
				wrap_string_conv(gen, token_list(list), value_pos);
			}
			tokens_parse(gen->GEN_func_tokens, list_src, ")", token_get_line(list));
		}
		else if (assignment == 3 && is_array(prev_type) && prev_type[0] == EXT_TYPE_STRUCT && (token_get_type(list) == '+=' || token_get_type(list) == '-=')) {
			token_next_nocheck(list);
			copy_func_tokens(gen, list);
			token_back(list);
			tokens_parse(gen->GEN_func_tokens, list_src, "((", token_get_line(list));
			token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
			if (gen->GEN_ret_type != TYPE_DYNAMIC && gen->GEN_ret_type != TYPE_INTEGER) {
				return 0, error({script_line(token_get_line(list)), ": struct pointer offset must be Integer"});
			}
			token_next_nocheck(list);
			copy_func_tokens(gen, list);
			token_back(list);
			tokens_parse(gen->GEN_func_tokens, list_src, {")*", type->CLASS_compat_name, "_SIZE)"}, token_get_line(list));
		}
		else if (assignment == 3 && is_array(prev_type) && prev_type[0] == EXT_TYPE_CLASS) {
			copy_func_tokens(gen, list);
			var line = token_get_line(list);
			var comma_off = token_get_offset(list);
			token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
			var ret_type = gen->GEN_ret_type;
			token_next_nocheck(list);
			copy_func_tokens(gen, list);
			token_back(list);

			var operator_list, operator_off;
			find_operator(&operator_list, &operator_off, prev_type, ret_type, op_prio);
			if (!operator_list) {
				find_operator(&operator_list, &operator_off, prev_type, TYPE_DYNAMIC, op_prio);
			}
			if (operator_list) {
				token_next_nocheck(list);
				copy_func_tokens(gen, list);
				token_back(list);
				var func_name = operator_list[operator_off+OPERATOR_func_name];
				var adj_off = hash_get(gen->GEN_func_offsets_replacements, off, off);
				insert_func_tokens(gen, list, adj_off, 2, &func_tokens, &func_pos);
				append_source(list_src, {"(,", func_name}, &src_off);
				insert_token(func_tokens, func_pos, TOK_IDENT, src_off+2, length(func_name), line);
				insert_token(func_tokens, func_pos, '(', src_off, 1, line);
				for (var j=length(func_tokens)-TOK_SIZE; j>=0; j-=TOK_SIZE) {
					if (func_tokens[j+TOK_off] == comma_off) {
						insert_token(func_tokens, j, ',', src_off+1, 1, line);
						break;
					}
				}
				tokens_parse(gen->GEN_func_tokens, list_src, ")", token_get_line(list));
			}
			else {
				return 0, error({script_line(token_get_line(list)), ": invalid assignment"});
			}
		}
		else {
			token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
			type = gen->GEN_ret_type;
		}

		if (assignment >= 2) {
			token_next_nocheck(list);
			copy_func_tokens(gen, list);
			token_back(list);
			//log({"prev=", prev_type, " type=", type});
			append_type_conv(gen, token_list(list), value_pos, prev_type, type);
		}
		break;
	}
	else {
		token_back(list);
	}
}

macro @expression_ternary()
{
	while (token_next(list) && token_is_symbol(list, '?')) {
		if (type == TYPE_INTEGER || type == TYPE_FLOAT) {
			return 0, error({script_line(token_get_line(list)), ": can't use integer or float in condition"});
		}
		token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
		var type1 = gen->GEN_ret_type;
		token_expect_symbol(list, ':');
		token_set_pos(list, parse_expression(gen, token_list(list), -1, token_get_pos(list), PRIO_PRIMARY));
		var type2 = gen->GEN_ret_type;
		if (type1 == TYPE_DYNAMIC) {
			type1 = type2;
		}
		if (type2 == TYPE_DYNAMIC) {
			type2 = type1;
		}
		if (!is_same_type(type1, type2)) {
			return 0, error({script_line(token_get_line(list)), ": both values in ternary operator must have the same type"});
		}
		type = type1;
	}
	token_back(list);
}

macro @expression_next_priority()
{
	switch (token_get_type(list)) {
 		case '*':   next_prio = PRIO_MULTIPLICATIVE_MUL; break;
 		case '/':   next_prio = PRIO_MULTIPLICATIVE_DIV; break;
 		case '%':   next_prio = PRIO_MULTIPLICATIVE_REM; break;
 		case '+':   next_prio = PRIO_ADDITIVE_ADD; break;
 		case '-':   next_prio = PRIO_ADDITIVE_SUB; break;
 		case '&':   next_prio = PRIO_BITWISE_AND; break;
 		case '|':   next_prio = PRIO_BITWISE_OR; break;
 		case '^':   next_prio = PRIO_BITWISE_XOR; break;
 		case '<':   next_prio = PRIO_COMPARISON_LT; break;
 		case '>':   next_prio = PRIO_COMPARISON_GT; break;
 		case '<<':  next_prio = PRIO_BITWISE_SHL; break;
 		case '>>':  next_prio = PRIO_BITWISE_SHR; break;
 		case '&&':  next_prio = PRIO_LOGICAL_AND; break;
 		case '||':  next_prio = PRIO_LOGICAL_OR; break;
 		case '<=':  next_prio = PRIO_COMPARISON_LE; break;
 		case '>=':  next_prio = PRIO_COMPARISON_GE; break;
 		case '==':  next_prio = PRIO_EQUALITY_EQ_VALUE; break;
 		case '!=':  next_prio = PRIO_EQUALITY_NE_VALUE; break;
 		case '===': next_prio = PRIO_EQUALITY_EQ_REF; break;
 		case '!==': next_prio = PRIO_EQUALITY_NE_REF; break;
 		case '>>>': next_prio = PRIO_BITWISE_USHR; break;
	}
}

function @parse_expression(gen, token_list(list), prev_type, start_pos, prio)
{
	var is_statement = false;
	if (prev_type == -2) {
		is_statement = true;
		prev_type = -1;
	}
	var outer = (prev_type == -1);
	var last_pos = token_get_pos(list) - TOK_SIZE;

	for (;;) {
		var type = -1;
		var off = token_get_pos(list);
		var unary_off = off;

		token_expect_next(list);

		for (;;) {
			expression_unary_detect();
			unary_off = token_get_pos(list) - TOK_SIZE;
			break;
		}
		
		expression_primary();

		if (type == -1) {
			return 0, error({script_line(token_get_line(list)), ": expected value"});
		}

		while (token_next(list)) {
			expression_primary_suffix();
			token_back(list);
			break;
		}

		while (unary_off > off) {
			expression_unary_process();
			unary_off -= TOK_SIZE;
		}

		if (token_next(list)) {
			var has_postincdec = false;
			switch (token_get_type(list)) {
				case '++', '--':
					has_postincdec = true;
					break;
			}
			if (has_postincdec) {
				if (is_array(type) && type[0] == EXT_TYPE_STRUCT) {
					var postincdec_type = token_get_type(list);
					copy_func_tokens(gen, list);
					token_next_nocheck(list);
					set_func_copy_start(gen, list);
					token_back(list);
					var line = token_get_line(list);
					insert_func_tokens(gen, list, off, 2, &func_tokens, &func_pos);
					append_source(list_src, "((", &src_off);
					insert_token(func_tokens, func_pos, '(', src_off+0, 1, line);
					insert_token(func_tokens, func_pos, '(', src_off+1, 1, line);
					var after = ")";
					if (!is_statement) {
						after = {postincdec_type == '++'? "-":"+", type->CLASS_compat_name, "_SIZE)"};
					}
					tokens_parse(gen->GEN_func_tokens, list_src, {postincdec_type == '++'? "+=" : "-=", type->CLASS_compat_name, "_SIZE)", after}, line);
				}
				else if (type != TYPE_DYNAMIC && type != TYPE_INTEGER) {
					return 0, error({script_line(token_get_line(list)), ": post increment/decrement is supported only for integers"});
				}
			}
			else if (token_is_ident(list, "as")) {
				copy_func_tokens(gen, list);
				var new_type;
				parse_type(&new_type, list);
				token_expect_next(list);
				set_func_copy_start(gen, list);
				token_back(list);
				var is_struct1 = is_array(type) && type[0] == EXT_TYPE_STRUCT;
				var is_struct2 = is_array(new_type) && new_type[0] == EXT_TYPE_STRUCT;
				if (is_struct1 && is_struct2) {
					var change = get_struct_size(new_type) - get_struct_size(type);
					if (change != 0) {
						var line = token_get_line(list);
						var prepend = tokens_parse([], list_src, change >= 0? "add32(" : "sub32(", line);
						insert_func_tokens(gen, list, off, 2, &func_tokens, &func_pos);
						array_copy(func_tokens, func_pos, prepend, 0, length(prepend));
						tokens_parse(gen->GEN_func_tokens, list_src, {", ", abs(change), ")"}, line);
					}
				}
				else if (is_struct1 && new_type != TYPE_DYNAMIC) {
					if (new_type != TYPE_INTEGER) {
						return 0, error({script_line(token_get_line(list)), ": can't convert struct reference to non-integer"});
					}
					var line = token_get_line(list);
					var prepend = tokens_parse([], list_src, "sub32(", line);
					insert_func_tokens(gen, list, off, 2, &func_tokens, &func_pos);
					array_copy(func_tokens, func_pos, prepend, 0, length(prepend));
					tokens_parse(gen->GEN_func_tokens, list_src, {", ", type->CLASS_compat_name, "_SIZE)"}, line);
				}
				else if (type != TYPE_DYNAMIC && is_struct2) {
					if (type != TYPE_INTEGER) {
						return 0, error({script_line(token_get_line(list)), ": can't convert struct reference from non-integer"});
					}
					var line = token_get_line(list);
					var prepend = tokens_parse([], list_src, "add32(", line);
					insert_func_tokens(gen, list, off, 2, &func_tokens, &func_pos);
					array_copy(func_tokens, func_pos, prepend, 0, length(prepend));
					tokens_parse(gen->GEN_func_tokens, list_src, {", ", new_type->CLASS_compat_name, "_SIZE)"}, line);
				}
				type = new_type;
			}
			else {
				token_back(list);
			}
		}

		if (token_next(list)) {
			expression_assignment();
		}

		var prev_last_pos = last_pos;
		last_pos = token_get_pos(list);
		if (!token_next(list)) {
			prev_type = type;
			break;
		}

		var next_prio = -1;
		expression_next_priority();
		if (next_prio == -1) {
			token_back(list);
			expression_operators(prev_last_pos);
			if (outer) {
				expression_ternary();
			}
			prev_type = type;
			break;
		}

		if ((next_prio >> 4) > (prio >> 4)) {
			token_set_pos(list, parse_expression(gen, token_list(list), type, off, next_prio));
			type = gen->GEN_ret_type;
			if (prev_type != -1) {
				expression_operators(prev_last_pos);
				expression_ternary();
			}
			if (token_next(list)) {
				next_prio = -1;
				expression_next_priority();
				token_back(list);
				if (next_prio == -1) {
					prev_type = type;
					break;
				}
			}
		}
		else {
			token_back(list);
			expression_operators(prev_last_pos);
			expression_ternary();
			token_next_nocheck(list);
		}

		prio = next_prio;
		prev_type = type;
	}

	gen->GEN_ret_type = prev_type;
	return token_get_pos(list);
}

function @parse_primary_expression(gen, token_list(list))
{
	var type = -1;
	var off = token_get_pos(list);
	var unary_off = off;

	token_expect_next(list);
		
	expression_primary();

	if (type == -1) {
		return 0, error({script_line(token_get_line(list)), ": expected value"});
	}

	while (token_next(list)) {
		expression_primary_suffix();
		token_back(list);
		break;
	}

	if (token_next(list)) {
		if (token_is_ident(list, "as")) {
			var is_struct1 = is_array(type) && type[0] == EXT_TYPE_STRUCT;
			copy_func_tokens(gen, list);
			parse_type(&type, list);
			token_expect_next(list);
			set_func_copy_start(gen, list);
			token_back(list);
			var is_struct2 = is_array(type) && type[0] == EXT_TYPE_STRUCT;
			if (is_struct1 || is_struct2) {
				return 0, error({script_line(token_get_line(list)), ": struct casting not applicable in this context"});
			}
		}
		else {
			token_back(list);
		}
	}

	gen->GEN_ret_type = type;
	return token_get_pos(list);
}

function @wrap_with_float_conv(gen, token_list(list), start_pos, end_pos)
{
	var line = token_get_line(list);
	copy_func_tokens(gen, list);
	insert_func_tokens(gen, list, start_pos, 2, &func_tokens, &func_pos);
	append_source(list_src, "float()", &src_off);
	insert_token(func_tokens, func_pos, TOK_IDENT, src_off, 5, line);
	insert_token(func_tokens, func_pos, '(', src_off+5, 1, line);
	if (end_pos != -1) {
		insert_func_tokens(gen, list, end_pos, 1, &func_tokens2, &func_pos2);
		insert_token(func_tokens2, func_pos2, ')', src_off+6, 1, line);
	}
	else {
		append_token(func_tokens, ')', src_off+6, 1, line);
	}
}

function @wrap_float_op(gen, token_list(list), start_pos)
{
	var line = token_get_line(list);
	insert_func_tokens(gen, list, start_pos, 1, &func_tokens, &func_pos);
	append_source(list_src, "{}", &src_off);
	insert_token(func_tokens, func_pos, '{', src_off, 1, line);
	append_token(func_tokens, '}', src_off+1, 1, line);
}

function @wrap_float_unary_op(gen, token_list(list), start_pos)
{
	var line = token_get_line(list);
	insert_func_tokens(gen, list, start_pos, 2, &func_tokens, &func_pos);
	append_source(list_src, "{0.0}", &src_off);
	insert_token(func_tokens, func_pos, '{', src_off, 1, line);
	insert_token(func_tokens, func_pos, TOK_FLOAT_NUMBER, src_off+1, 3, line);
	append_token(func_tokens, '}', src_off+4, 1, line);
}

function @wrap_concat_op(gen, token_list(list), start_pos, operator_pos)
{
	var line = token_get_line(list);
	insert_func_tokens(gen, list, start_pos, 1, &func_tokens, &func_pos);
	append_source(list_src, "{},", &src_off);
	insert_token(func_tokens, func_pos, '{', src_off, 1, line);
	append_token(func_tokens, '}', src_off+1, 1, line);

	var off = list_tokens[operator_pos+TOK_off];
	for (var i=length(func_tokens)-TOK_SIZE; ; i-=TOK_SIZE) {
		if (func_tokens[i+TOK_off] == off) {
			func_tokens[i+TOK_type] = ',';
			func_tokens[i+TOK_off] = src_off+2;
			func_tokens[i+TOK_len] = 1;
			break;
		}
	}
}

function @wrap_string_conv(gen, token_list(list), start_pos)
{
	var line = token_get_line(list);
	insert_func_tokens(gen, list, start_pos, 2, &func_tokens, &func_pos);
	append_source(list_src, "{()}", &src_off);
	insert_token(func_tokens, func_pos, '{', src_off, 1, line);
	insert_token(func_tokens, func_pos, '(', src_off+1, 1, line);
	append_token(func_tokens, ')', src_off+2, 1, line);
	append_token(func_tokens, '}', src_off+3, 1, line);
}

function @wrap_operator_op(gen, token_list(list), start_pos, operator_pos, func_name, compare, prio)
{
	var line = token_get_line(list);
	var comma_off;

	insert_func_tokens(gen, list, start_pos, compare? 3 : 2, &func_tokens, &func_pos);
	if (compare) {
		var expr;
		switch (prio) {
			case PRIO_COMPARISON_LT:     expr = "<0"; break;
			case PRIO_COMPARISON_GT:     expr = ">0"; break;
			case PRIO_COMPARISON_LE:     expr = "<=0"; break;
			case PRIO_COMPARISON_GE:     expr = ">=0"; break;
			case PRIO_EQUALITY_EQ_VALUE: expr = "==0"; break;
			case PRIO_EQUALITY_NE_VALUE: expr = "!=0"; break;
		}
		append_source(list_src, {"((,", func_name}, &src_off);
		insert_token(func_tokens, func_pos, '(', src_off, 1, line);
		insert_token(func_tokens, func_pos, TOK_IDENT, src_off+3, length(func_name), line);
		insert_token(func_tokens, func_pos, '(', src_off+1, 1, line);
		tokens_parse(func_tokens, list_src, {")", expr, ")"}, line);
		comma_off = src_off+2;
	}
	else {
		append_source(list_src, {"(),", func_name}, &src_off);
		insert_token(func_tokens, func_pos, TOK_IDENT, src_off+3, length(func_name), line);
		insert_token(func_tokens, func_pos, '(', src_off, 1, line);
		append_token(func_tokens, ')', src_off+1, 1, line);
		comma_off = src_off+2;
	}

	var off = list_tokens[operator_pos+TOK_off];
	for (var i=length(func_tokens)-TOK_SIZE; ; i-=TOK_SIZE) {
		if (func_tokens[i+TOK_off] == off) {
			func_tokens[i+TOK_type] = ',';
			func_tokens[i+TOK_off] = comma_off;
			func_tokens[i+TOK_len] = 1;
			break;
		}
	}
}

function @wrap_struct_conv(gen, token_list(list), start_pos, operator_pos, type)
{
	var line = token_get_line(list);
	var size_name = {type->CLASS_compat_name, "_SIZE"};

	append_source(list_src, {"(),sub32", size_name}, &src_off);
	insert_func_tokens(gen, list, start_pos, 2, &func_tokens1, &func_pos1);
	insert_token(func_tokens1, func_pos1, TOK_IDENT, src_off+3, 5, line);
	insert_token(func_tokens1, func_pos1, '(', src_off+0, 1, line);
	if (operator_pos == -1) {
		var func_tokens2 = gen->GEN_func_tokens;
		append_token(func_tokens2, ',', src_off+2, 1, line);
		append_token(func_tokens2, TOK_IDENT, src_off+8, length(size_name), line);
		append_token(func_tokens2, ')', src_off+1, 1, line);
	}
	else {
		insert_func_tokens_adj(gen, list, operator_pos, -TOK_SIZE, 3, &func_tokens2, &func_pos2);
		insert_token(func_tokens2, func_pos2, ',', src_off+2, 1, line);
		insert_token(func_tokens2, func_pos2, TOK_IDENT, src_off+8, length(size_name), line);
		insert_token(func_tokens2, func_pos2, ')', src_off+1, 1, line);
	}
}

function @append_type_conv(gen, token_list(list), start_pos, dest_type, src_type)
{
	if (dest_type == -1) {
		dest_type = TYPE_DYNAMIC;
	}
	if (dest_type == src_type) {
		return;
	}

	//log({"dest_type=", dest_type, " src_type=", src_type});
	if (dest_type == TYPE_FLOAT) {
		if (src_type == TYPE_FLOAT) return;
		if (src_type != TYPE_INTEGER) {
			return 0, error({script_line(token_get_line(list)), ": not an Integer or Float"});
		}

		token_next_nocheck(list);
		copy_func_tokens(gen, list);
		wrap_with_float_conv(gen, token_list(list), start_pos, -1);
		token_back(list);
		return;
	}

	if (!check_implicit_conv(dest_type, src_type)) {
		return 0, error({script_line(token_get_line(list)), ": cannot implicitly convert from ", get_type_name(src_type), " to ", get_type_name(dest_type)});
	}
}

function @check_implicit_conv(dest_type, src_type)
{
	if (dest_type == src_type) {
		return true;
	}

	if (dest_type == TYPE_FLOAT) {
		if (src_type == TYPE_FLOAT) return true;
		if (src_type != TYPE_INTEGER) {
			return false;
		}
		return true;
	}

	if (src_type == TYPE_STRING && is_integer_or_dynamic_array(dest_type)) {
		return true;
	}

	if (is_array(src_type) && src_type[0] == EXT_TYPE_ARRAY && src_type->ARRAY_base_type == TYPE_DYNAMIC) {
		if (is_array(dest_type) && dest_type[0] == EXT_TYPE_STRUCT_ARRAY) {
			return true;
		}
	}
	if (is_array(src_type) && src_type[0] == EXT_TYPE_STRUCT_ARRAY) {
		if (is_array(dest_type) && dest_type[0] == EXT_TYPE_ARRAY && dest_type->ARRAY_base_type == TYPE_DYNAMIC) {
			return true;
		}
	}

	if (is_array(dest_type) && dest_type[0] == EXT_TYPE_ARRAY && is_array(src_type) && src_type[0] == EXT_TYPE_ARRAY) {
		var dest = dest_type->ARRAY_base_type;
		var src = src_type->ARRAY_base_type;
		if ((dest == TYPE_DYNAMIC && src == TYPE_FLOAT) || (dest == TYPE_FLOAT && src == TYPE_DYNAMIC)) {
			return true;
		}
		return check_implicit_conv(dest, src);
	}

	if (is_array(dest_type) && dest_type[0] == EXT_TYPE_HASH && is_array(src_type) && src_type[0] == EXT_TYPE_HASH) {
		var dest1 = dest_type->HASH_base_type;
		var dest2 = dest_type->HASH_index_type;
		var src1 = src_type->HASH_base_type;
		var src2 = src_type->HASH_index_type;
		if ((dest1 == TYPE_DYNAMIC && src1 == TYPE_FLOAT) || (dest1 == TYPE_FLOAT && src1 == TYPE_DYNAMIC)) {
			return true;
		}
		if ((dest2 == TYPE_DYNAMIC && src2 == TYPE_FLOAT) || (dest2 == TYPE_FLOAT && src2 == TYPE_DYNAMIC)) {
			return true;
		}
		if (!check_implicit_conv(dest1, src1)) return false;
		if (!check_implicit_conv(dest2, src2)) return false;
		return true;
	}

	var dest_class = get_type_class(dest_type);
	var src_class = get_type_class(src_type);
	if (dest_class && src_class) {
		while (src_class) {
			if (src_class === dest_class) {
				return true;
			}
			src_class = src_class->CLASS_parent;
		}
	}

	if (dest_type != TYPE_DYNAMIC && src_type != TYPE_DYNAMIC) {
		if (is_array(dest_type) && dest_type[0] == EXT_TYPE_MULTIPLE) {
			for (var i=1; i<length(dest_type); i++) {
				if (check_implicit_conv(dest_type[i], src_type)) {
					return true;
				}
			}
		}
		return false;
	}
	return true;
}

function @check_implicit_conv_with_error(dest_type, src_type, line)
{
	if (!check_implicit_conv(dest_type, src_type)) {
		return 0, error({script_line(line), ": cannot implicitly convert from ", get_type_name(src_type), " to ", get_type_name(dest_type)});
	}
}

function @is_same_type(type1, type2)
{
	if (type1 == type2) return true;
	return false;
}

function @is_compatible_type(dest_type, src_type)
{
	return check_implicit_conv(dest_type, src_type);
}

function @get_type_name(type)
{
	if (is_array(type)) {
		switch (type[0]) {
			case EXT_TYPE_CLASS:
			case EXT_TYPE_STRUCT:
				return type->CLASS_name;

			case EXT_TYPE_ARRAY:
				return {get_type_name(type->ARRAY_base_type), "[]"};

			case EXT_TYPE_HASH:
				return {get_type_name(type->HASH_base_type), "[", get_type_name(type->HASH_index_type), "]"};

			case EXT_TYPE_STRUCT_ARRAY:
				return {"[", get_type_name(type->ARRAY_base_type), "]"};

			case EXT_TYPE_MULTIPLE: {
				var s = {get_type_name(type[1])};
				for (var i=2; i<length(type); i++) {
					array_append(s, " or ");
					array_append(s, get_type_name(type[i]));
				}
				return s;
			}
		}
		return "???";
	}
	switch (type) {
		case TYPE_DYNAMIC: return "Dynamic";
		case TYPE_VOID:    return "Void";
		case TYPE_INTEGER: return "Integer";
		case TYPE_FLOAT:   return "Float";
		case TYPE_BOOLEAN: return "Boolean";
		case TYPE_STRING:  return "String";
		case TYPE_KEY:     return "<Key>";
		case TYPE_VALUE:   return "<Value>";
	}
	return "???";
}

function @get_type_class(type)
{
	if (is_array(type) && type[0] == EXT_TYPE_CLASS) {
		return type;
	}
	return null;
}

function @get_type_class_or_struct(type)
{
	if (is_array(type)) {
		switch (type[0]) {
			case EXT_TYPE_CLASS:
			case EXT_TYPE_STRUCT:
				return type;
		}
	}
	return null;
}

function @get_type_array_or_hash(type)
{
	if (is_array(type)) {
		switch (type[0]) {
			case EXT_TYPE_ARRAY:
			case EXT_TYPE_HASH:
				return type;
		}
	}
	return null;
}

function @get_class_name_with_kind(class)
{
	return {class->CLASS_ext_type == EXT_TYPE_STRUCT? "struct " : "class ", class->CLASS_name};
}

function @is_integer_or_dynamic_array(type)
{
	return (is_array(type) && type[0] == EXT_TYPE_ARRAY && (type->ARRAY_base_type == TYPE_INTEGER || type->ARRAY_base_type == TYPE_DYNAMIC));
}

function @get_struct_size(type)
{
	var size = 0;
	while (type) {
		size += length(type->CLASS_fields);
		type = type->CLASS_parent;
	}
	return size;
}

function @get_struct_field(gen, type, name)
{
	var size = 0;
	while (type) {
		var fields = type->CLASS_fields;
		for (var i=0; i<length(fields); i++) {
			var (field_name, field) = hash_entry(fields, i);
			if (field_name == name && (!field->FIELD_private || type === hash_get(gen->GEN_classes, type->CLASS_name, null))) {
				return field->FIELD_type, size + (length(fields) - i);
			}
		}
		size += length(fields);
		type = type->CLASS_parent;
	}
	return -1, -1;
}

function @find_to_string_function(cls)
{
	while (cls) {
		var func = hash_get(cls->CLASS_functions, "to_string#1", null);
		if (func && (func->FUNC_flags & (FUNC_FLAG_STATIC | FUNC_FLAG_PRIVATE | FUNC_FLAG_OVERRIDE)) == 0) {
			return cls;
		}
		cls = cls->CLASS_parent;
	}
	return null;
}

function @init_builtin_functions()
{
	builtin_functions = {};

	var I = TYPE_INTEGER;
	var F = TYPE_FLOAT;
	var D = TYPE_DYNAMIC;
	var B = TYPE_BOOLEAN;
	var S = TYPE_STRING;
	var V = TYPE_VOID;
	var A = create_array_type(TYPE_DYNAMIC);
	var H = create_hash_type(TYPE_DYNAMIC, TYPE_DYNAMIC);
	var aI = create_array_type(TYPE_INTEGER);
	var aS = create_array_type(TYPE_STRING);
	var aKey = create_array_type(TYPE_KEY);
	var aValue = create_array_type(TYPE_VALUE);
	var hDS = create_hash_type(TYPE_DYNAMIC, TYPE_STRING);
	var Key = TYPE_KEY;
	var Value = TYPE_VALUE;
	var param_names = [];
	var _ = create_params(param_names, []);
	var _I = create_params(param_names, [I]);
	var _F = create_params(param_names, [F]);
	var _FF = create_params(param_names, [F, F]);
	var _FFF = create_params(param_names, [F, F, F]);
	var _D = create_params(param_names, [D]);
	var _A = create_params(param_names, [A]);
	var _H = create_params(param_names, [H]);
	var _aI = create_params(param_names, [aI]);
	var _II = create_params(param_names, [I, I]);
	var _III = create_params(param_names, [I, I, I]);
	var _IIII = create_params(param_names, [I, I, I, I]);
	var _IIIIII = create_params(param_names, [I, I, I, I, I, I]);
	var _IIF = create_params(param_names, [I, I, F]);
	var _IIFF = create_params(param_names, [I, I, F, F]);
	var _DI = create_params(param_names, [D, I]);
	var _DS = create_params(param_names, [D, S]);
	var _DD = create_params(param_names, [D, D]);
	var _AD = create_params(param_names, [A, D]);
	var _AI = create_params(param_names, [A, I]);
	var _AA = create_params(param_names, [A, A]);
	var _HI = create_params(param_names, [H, I]);
	var _HD = create_params(param_names, [H, D]);
	var _SaI = create_params(param_names, [S, aI]);
	var _aIS = create_params(param_names, [aI, S]);
	var _aID = create_params(param_names, [aI, D]);
	var _aIaI = create_params(param_names, [aI, aI]);
	var _AAII = create_params(param_names, [A, A, I, I]);
	var _AID = create_params(param_names, [A, I, D]);
	var _AIA = create_params(param_names, [A, I, A]);
	var _DDD = create_params(param_names, [D, D, D]);
	var _AII = create_params(param_names, [A, I, I]);
	var _HDD = create_params(param_names, [H, D, D]);
	var _aIII = create_params(param_names, [aI, I, I]);
	var _AIAII = create_params(param_names, [A, I, A, I, I]);
	var _AIID = create_params(param_names, [A, I, I, D]);
	var _AIIA = create_params(param_names, [A, I, I, A]);
	var _SaIII = create_params(param_names, [S, aI, I, I]);
	var _aISII = create_params(param_names, [aI, S, I, I]);
	var _AIIAII = create_params(param_names, [A, I, I, A, I, I]);
	var _SDSI = create_params(param_names, [S, D, S, I]);
	var _DSSI = create_params(param_names, [D, S, S, I]);
	var _DSSIII = create_params(param_names, [D, S, S, I, I, I]);
	var _DB = create_params(param_names, [D, B]);
	var _S = create_params(param_names, [S]);
	var _SI = create_params(param_names, [S, I]);
	var _SII = create_params(param_names, [S, I, I]);
	var _SIII = create_params(param_names, [S, I, I, I]);
	var _SIIII = create_params(param_names, [S, I, I, I, I]);
	var _SF = create_params(param_names, [S, F]);
	var _SIIF = create_params(param_names, [S, I, I, F]);
	var _SShDSaSaS = create_params(param_names, [S, S, hDS, aS, aS]);
	var _aValueIaValueII = create_params(param_names, [aValue, I, aValue, I, I]);
	var _AValue = create_params(param_names, [A, Value]);
	var _AIIValue = create_params(param_names, [A, I, I, Value]);
	var _AIValue = create_params(param_names, [A, I, Value]);
	var _AIaValue = create_params(param_names, [A, I, aValue]);
	var _AIaValueII = create_params(param_names, [A, I, aValue, I, I]);
	var _AaValue = create_params(param_names, [A, aValue]);
	var _AaValueII = create_params(param_names, [A, aValue, I, I]);
	var _AIIaValue = create_params(param_names, [A, I, I, aValue]);
	var _AIIaValueII = create_params(param_names, [A, I, I, aValue, I, I]);
	var _HKeyValue = create_params(param_names, [H, Key, Value]);
	var _HKey = create_params(param_names, [H, Key]);
	var _SIS = create_params(param_names, [S, I, S]);
	var _SISII = create_params(param_names, [S, I, S, I, I]);
	var _SS = create_params(param_names, [S, S]);
	var _SSII = create_params(param_names, [S, S, I, I]);
	var _SIIS = create_params(param_names, [S, I, I, S]);
	var _SIISII = create_params(param_names, [S, I, I, S, I, I]);
	var _ArrayOrHash = create_params(param_names, [[EXT_TYPE_MULTIPLE, A, H]]);

	add_builtin_function("length",     I,   _ArrayOrHash);
	add_builtin_function("min",        I,   _II);
	add_builtin_function("max",        I,   _II);
	add_builtin_function("clamp",      I,   _III);
	add_builtin_function("abs",        I,   _I);
	add_builtin_function("add32",      I,   _II);
	add_builtin_function("add32",      I,I, _II);
	add_builtin_function("add32",      I,   _III);
	add_builtin_function("add32",      I,I, _III);
	add_builtin_function("sub32",      I,   _II);
	add_builtin_function("sub32",      I,I, _II);
	add_builtin_function("sub32",      I,   _III);
	add_builtin_function("sub32",      I,I, _III);
	add_builtin_function("mul32",      I,   _II);
	add_builtin_function("add64",      I,I, _IIII);
	add_builtin_function("sub64",      I,I, _IIII);
	add_builtin_function("mul64",      I,I, _II);
	add_builtin_function("umul64",     I,I, _II);
	add_builtin_function("mul64",      I,I, _IIII);
	add_builtin_function("div64",      I,I, _IIII);
	add_builtin_function("udiv64",     I,I, _IIII);
	add_builtin_function("rem64",      I,I, _IIII);
	add_builtin_function("urem64",     I,I, _IIII);
	add_builtin_function("float",      F,   _I);
	add_builtin_function("float",      I,I, _II);
	add_builtin_function("int",        I,   _F);
	add_builtin_function("int",        I,I, _II);
	add_builtin_function("fconv",      I,I, _F);
	add_builtin_function("fconv",      F,   _II);
	add_builtin_function("fadd",       I,I, _IIF);
	add_builtin_function("fadd",       I,I, _IIII);
	add_builtin_function("fsub",       I,I, _IIF);
	add_builtin_function("fsub",       I,I, _IIII);
	add_builtin_function("fmul",       I,I, _IIF);
	add_builtin_function("fmul",       I,I, _IIII);
	add_builtin_function("fdiv",       I,I, _IIF);
	add_builtin_function("fdiv",       I,I, _IIII);
	add_builtin_function("fcmp_lt",    B,   _IIF);
	add_builtin_function("fcmp_lt",    B,   _IIII);
	add_builtin_function("fcmp_le",    B,   _IIF);
	add_builtin_function("fcmp_le",    B,   _IIII);
	add_builtin_function("fcmp_gt",    B,   _IIF);
	add_builtin_function("fcmp_gt",    B,   _IIII);
	add_builtin_function("fcmp_ge",    B,   _IIF);
	add_builtin_function("fcmp_ge",    B,   _IIII);
	add_builtin_function("fcmp_eq",    B,   _IIF);
	add_builtin_function("fcmp_eq",    B,   _IIII);
	add_builtin_function("fcmp_ne",    B,   _IIF);
	add_builtin_function("fcmp_ne",    B,   _IIII);
	add_builtin_function("fabs",       F,   _F);
	add_builtin_function("fabs",       I,I, _II);
	add_builtin_function("fmin",       F,   _FF);
	add_builtin_function("fmin",       I,I, _IIF);
	add_builtin_function("fmin",       I,I, _IIII);
	add_builtin_function("fmax",       F,   _FF);
	add_builtin_function("fmax",       I,I, _IIF);
	add_builtin_function("fmax",       I,I, _IIII);
	add_builtin_function("fclamp",     F,   _FFF);
	add_builtin_function("fclamp",     I,I, _IIFF);
	add_builtin_function("fclamp",     I,I, _IIIIII);
	add_builtin_function("floor",      F,   _F);
	add_builtin_function("floor",      I,I, _II);
	add_builtin_function("ifloor",     I,   _F);
	add_builtin_function("ifloor",     I,I, _II);
	add_builtin_function("ceil",       F,   _F);
	add_builtin_function("ceil",       I,I, _II);
	add_builtin_function("iceil",      I,   _F);
	add_builtin_function("iceil",      I,I, _II);
	add_builtin_function("round",      F,   _F);
	add_builtin_function("round",      I,I, _II);
	add_builtin_function("iround",     I,   _F);
	add_builtin_function("iround",     I,I, _II);
	add_builtin_function("pow",        F,   _FF);
	add_builtin_function("pow",        I,I, _IIF);
	add_builtin_function("pow",        I,I, _IIII);
	add_builtin_function("sqrt",       F,   _F);
	add_builtin_function("sqrt",       I,I, _II);
	add_builtin_function("cbrt",       F,   _F);
	add_builtin_function("cbrt",       I,I, _II);
	add_builtin_function("exp",        F,   _F);
	add_builtin_function("exp",        I,I, _II);
	add_builtin_function("ln",         F,   _F);
	add_builtin_function("ln",         I,I, _II);
	add_builtin_function("log2",       F,   _F);
	add_builtin_function("log2",       I,I, _II);
	add_builtin_function("log10",      F,   _F);
	add_builtin_function("log10",      I,I, _II);
	add_builtin_function("sin",        F,   _F);
	add_builtin_function("sin",        I,I, _II);
	add_builtin_function("cos",        F,   _F);
	add_builtin_function("cos",        I,I, _II);
	add_builtin_function("asin",       F,   _F);
	add_builtin_function("asin",       I,I, _II);
	add_builtin_function("acos",       F,   _F);
	add_builtin_function("acos",       I,I, _II);
	add_builtin_function("tan",        F,   _F);
	add_builtin_function("tan",        I,I, _II);
	add_builtin_function("atan",       F,   _F);
	add_builtin_function("atan",       I,I, _II);
	add_builtin_function("atan2",      F,   _FF);
	add_builtin_function("atan2",      I,I, _IIII);
	add_builtin_function("is_int",     B,   _D);
	add_builtin_function("is_float",   B,   _D);
	add_builtin_function("is_array",   B,   _D);
	add_builtin_function("is_string",  B,   _D);
	add_builtin_function("is_hash",    B,   _D);
	add_builtin_function("is_shared",  B,   _D);
	add_builtin_function("is_const",   B,   _D);
	add_builtin_function("is_funcref", B,   _D);
	add_builtin_function("is_weakref", B,   _D);
	add_builtin_function("is_handle",  B,   _D);

	add_builtin_function("clone",                  D, _D);
	add_builtin_function("clone_deep",             D, _D);
	add_builtin_function("array_create",           A, _I);
	add_builtin_function("array_create",           A, _II);
	add_builtin_function("array_create_shared",    A, _II);
	add_builtin_function("array_get_shared_count", I, _A);
	add_builtin_function("array_get_element_size", I, _A);
	add_builtin_function("array_set_length",       V, _AI);
	add_builtin_function("array_copy",             V, _AIAII);
	add_builtin_function("array_fill",             V, _AD);
	add_builtin_function("array_fill",             V, _AIID);
	add_builtin_function("array_extract",          D, _AII);
	add_builtin_function("array_insert",           V, _AID);
	add_builtin_function("array_insert_array",     V, _AIA);
	add_builtin_function("array_insert_array",     V, _AIAII);
	add_builtin_function("array_append",           V, _AA);
	add_builtin_function("array_append",           V, _AAII);
	add_builtin_function("array_replace_range",    V, _AIIA);
	add_builtin_function("array_replace_range",    V, _AIIAII);
	add_builtin_function("array_remove",           V, _AI);
	add_builtin_function("array_remove",           V, _AII);
	add_builtin_function("array_clear",            V, _A);
	add_builtin_function("string_const",           S, _S);
	add_builtin_function("string_const",           S, _SII);
	add_builtin_function("string_parse_int",       I, _S);
	add_builtin_function("string_parse_int",       I, _SI);
	add_builtin_function("string_parse_int",       I, _SII);
	add_builtin_function("string_parse_int",       I, _SIII);
	add_builtin_function("string_parse_float",     F, _S);
	add_builtin_function("string_parse_float",     F, _SF);
	add_builtin_function("string_parse_float",     F, _SII);
	add_builtin_function("string_parse_float",     F, _SIIF);
	add_builtin_function("string_parse_long",      I,I, _S);
	add_builtin_function("string_parse_long",      I,I, _SII);
	add_builtin_function("string_parse_long",      I,I, _SIIII);
	add_builtin_function("string_parse_double",    I,I, _S);
	add_builtin_function("string_parse_double",    I,I, _SII);
	add_builtin_function("string_parse_double",    I,I, _SIIII);
	add_builtin_function("string_from_long",       S, _II);
	add_builtin_function("string_from_long",       S, _SII);
	add_builtin_function("string_from_double",     S, _II);
	add_builtin_function("string_from_double",     S, _SII);
	add_builtin_function("string_from_utf8",       S, _aI);
	add_builtin_function("string_from_utf8",       S, _SaI);
	add_builtin_function("string_from_utf8",       S, _aIII);
	add_builtin_function("string_from_utf8",       S, _SaIII);
	add_builtin_function("string_to_utf8",         aI, _S);
	add_builtin_function("string_to_utf8",         aI, _aIS);
	add_builtin_function("string_to_utf8",         aI, _SII);
	add_builtin_function("string_to_utf8",         aI, _aISII);
	add_builtin_function("object_create",          D, _I);
	add_builtin_function("object_extend",          D, _DI);
	add_builtin_function("weakref_create",         D, _D);
	add_builtin_function("weakref_create",         D, _DD);
	add_builtin_function("weakref_create",         D, _DDD);
	add_builtin_function("weakref_get",            D, _D);
	add_builtin_function("hash_get",               D, _HDD);
	add_builtin_function("hash_entry",             D,D, _HI);
	add_builtin_function("hash_contains",          B, _HD);
	add_builtin_function("hash_remove",            D, _HD);
	add_builtin_function("hash_keys",              A, _H);
	add_builtin_function("hash_values",            A, _H);
	add_builtin_function("hash_pairs",             A, _H);
	add_builtin_function("hash_clear",             V, _H);
	add_builtin_function("error",                  D, _D);
	add_builtin_function("log",                    V, _D);
	add_builtin_function("dump",                   V, _D);
	add_builtin_function("to_string",              S, _D);
	add_builtin_function("to_string",              S, _DB);
	add_builtin_function("heap_collect",           V, _);
	add_builtin_function("heap_size",              I, _);
	add_builtin_function("perf_reset",             V, _);
	add_builtin_function("perf_log",               V, _D);
	add_builtin_function("serialize",              aI, _D);
	add_builtin_function("serialize",              aI, _aID);
	add_builtin_function("unserialize",            D, _aI);
	add_builtin_function("unserialize",            D, _aIII);
	add_builtin_function("unserialize",            D, _aIaI);
	add_builtin_function("script_query",           V, _SShDSaSaS);
	add_builtin_function("script_line",            S, _I);
	add_builtin_function("script_line",            S, _SDSI);
	add_builtin_function("script_postprocess",     V, _DD);
	add_builtin_function("script_compile",         D, _S);
	add_builtin_function("script_compile",         D, _DS);
	add_builtin_function("tokens_parse",           D, _DSSI);
	add_builtin_function("tokens_parse",           D, _DSSIII);
	add_builtin_function("token_parse_string",     S, _S);
	add_builtin_function("token_parse_string",     S, _SII);
	add_builtin_function("token_escape_string",    S, _S);

	builtin_static_functions = {};
	builtin_instance_functions = {};

	add_builtin_static_function("array_create",        A, _I);
	add_builtin_static_function("array_create",        A, _II);
	add_builtin_static_function("array_create_shared", A, _II);
	add_builtin_static_function("array_copy",          V, _aValueIaValueII);

	add_builtin_instance_function("array_get_shared_count", I, _A);
	add_builtin_instance_function("array_get_element_size", I, _A);
	add_builtin_instance_function("array_set_length",       V, _AI);
	add_builtin_instance_function("array_fill",             V, _AValue);
	add_builtin_instance_function("array_fill",             V, _AIIValue);
	add_builtin_instance_function("array_extract",          aValue, _AII);
	add_builtin_instance_function("array_insert",           V, _AIValue);
	add_builtin_instance_function("array_insert_array",     V, _AIaValue);
	add_builtin_instance_function("array_insert_array",     V, _AIaValueII);
	add_builtin_instance_function("array_append",           V, _AaValue);
	add_builtin_instance_function("array_append",           V, _AaValueII);
	add_builtin_instance_function("array_replace_range",    V, _AIIaValue);
	add_builtin_instance_function("array_replace_range",    V, _AIIaValueII);
	add_builtin_instance_function("array_remove",           V, _AI);
	add_builtin_instance_function("array_remove",           V, _AII);
	add_builtin_instance_function("array_clear",            V, _A);

	add_builtin_static_function("string_parse_int",       I, _S);
	add_builtin_static_function("string_parse_int",       I, _SI);
	add_builtin_static_function("string_parse_int",       I, _SII);
	add_builtin_static_function("string_parse_int",       I, _SIII);
	add_builtin_static_function("string_parse_float",     F, _S);
	add_builtin_static_function("string_parse_float",     F, _SF);
	add_builtin_static_function("string_parse_float",     F, _SII);
	add_builtin_static_function("string_parse_float",     F, _SIIF);
	/*
	TODO:
	add_builtin_static_function("string_parse_long",      I,I, _S);
	add_builtin_static_function("string_parse_long",      I,I, _SII);
	add_builtin_static_function("string_parse_long",      I,I, _SIIII);
	add_builtin_static_function("string_parse_double",    I,I, _S);
	add_builtin_static_function("string_parse_double",    I,I, _SII);
	add_builtin_static_function("string_parse_double",    I,I, _SIIII);
	add_builtin_static_function("string_from_long",       S, _II);
	add_builtin_static_function("string_from_long",       S, _SII);
	add_builtin_static_function("string_from_double",     S, _II);
	add_builtin_static_function("string_from_double",     S, _SII);
	*/
	add_builtin_static_function("string_from_utf8",       S, _aI);
	add_builtin_static_function("string_from_utf8",       S, _SaI);
	add_builtin_static_function("string_from_utf8",       S, _aIII);
	add_builtin_static_function("string_from_utf8",       S, _SaIII);
	add_builtin_static_function("string_to_utf8",         aI, _aIS);
	add_builtin_static_function("string_to_utf8",         aI, _aISII);

	add_builtin_instance_function_str("string_get_element_size", I, _S);
	add_builtin_instance_function_str("string_set_length",       V, _SI);
	add_builtin_instance_function_str("string_fill",             V, _SI);
	add_builtin_instance_function_str("string_fill",             V, _SIII);
	add_builtin_instance_function_str("string_extract",          S, _SII);
	add_builtin_instance_function_str("string_insert",           V, _SIS)->FUNC_alt_name = "array_insert_array";
	add_builtin_instance_function_str("string_insert",           V, _SISII)->FUNC_alt_name = "array_insert_array";
	add_builtin_instance_function_str("string_insert_char",      V, _SII)->FUNC_alt_name = "array_insert";
	add_builtin_instance_function_str("string_append",           V, _SS);
	add_builtin_instance_function_str("string_append",           V, _SSII);
	add_builtin_instance_function_str("string_replace_range",    V, _SIIS);
	add_builtin_instance_function_str("string_replace_range",    V, _SIISII);
	add_builtin_instance_function_str("string_remove",           V, _SI);
	add_builtin_instance_function_str("string_remove",           V, _SII);
	add_builtin_instance_function_str("string_clear",            V, _S);

	add_builtin_instance_function("string_as_const",   S,  _S)->FUNC_alt_name = "string_const";
	add_builtin_instance_function("string_as_const",   S,  _SII)->FUNC_alt_name = "string_const";
	add_builtin_instance_function("string_to_utf8",    aI, _S);
	add_builtin_instance_function("string_to_utf8",    aI, _SII);

	add_builtin_instance_function("hash_get",        Value, _HKeyValue);
	add_builtin_instance_function("hash_entry",      Key, _HI); // handled specially
	add_builtin_instance_function("hash_contains",   B, _HKey);
	add_builtin_instance_function("hash_remove",     D, _HKey);
	add_builtin_instance_function("hash_get_keys",   aKey, _H)->FUNC_alt_name = "hash_keys";
	add_builtin_instance_function("hash_get_values", aValue, _H)->FUNC_alt_name = "hash_values";
	add_builtin_instance_function("hash_get_pairs",  A, _H)->FUNC_alt_name = "hash_pairs";
	add_builtin_instance_function("hash_clear",      V, _H);
}

function @create_params(param_names, param_types)
{
	var params = {};
	for (var i=0; i<length(param_types); i++) {
		if (i == length(param_names)) {
			param_names[] = string_const({"p", i});
		}
		params{param_names[i]} = param_types[i];
	}
	return params;
}

function @add_builtin_function(name, ret_type, params)
{
	var func = object_create(FUNC_SIZE);
	func->FUNC_name = name;
	func->FUNC_return_type = ret_type;
	func->FUNC_flags = FUNC_FLAG_STATIC;
	func->FUNC_params = params;
	builtin_functions{string_const({name, "#", length(params)})} = func;
}

function @add_builtin_function(name, ret_type1, ret_type2, param_types)
{
	// TODO
}

function @add_builtin_static_function(name, ret_type, params)
{
	var func = object_create(FUNC_SIZE);
	func->FUNC_name = name;
	func->FUNC_return_type = ret_type;
	func->FUNC_flags = FUNC_FLAG_STATIC | FUNC_FLAG_EXTENSION;
	func->FUNC_params = params;
	builtin_static_functions{string_const({name, "#", length(params)})} = func;
	return func;
}

function @add_builtin_instance_function(name, ret_type, params)
{
	var func = object_create(FUNC_SIZE);
	func->FUNC_name = name;
	func->FUNC_return_type = ret_type;
	func->FUNC_flags = FUNC_FLAG_EXTENSION;
	func->FUNC_params = params;
	builtin_instance_functions{string_const({name, "#", length(params)})} = func;
	return func;
}

function @add_builtin_instance_function_str(name, ret_type, params)
{
	var func = add_builtin_instance_function(name, ret_type, params);
	func->FUNC_alt_name = string_const({"array_", array_extract(name, 7, length(name)-7)});
	return func;
}
